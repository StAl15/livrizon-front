{"ast":null,"code":"import { getIt } from 'get-it';\nimport { jsonRequest, jsonResponse, progress, observable } from 'get-it/middleware';\nimport { Observable, lastValueFrom } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\nimport polyfilledEventSource from '@sanity/eventsource';\nvar envMiddleware = [];\nclass ClientError extends Error {\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message);\n    this.statusCode = 400;\n    Object.assign(this, props);\n  }\n}\nclass ServerError extends Error {\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message);\n    this.statusCode = 500;\n    Object.assign(this, props);\n  }\n}\nfunction extractErrorProps(res) {\n  const body = res.body;\n  const props = {\n    response: res,\n    statusCode: res.statusCode,\n    responseBody: stringifyBody(body, res),\n    message: \"\",\n    details: void 0\n  };\n  if (body.error && body.message) {\n    props.message = \"\".concat(body.error, \" - \").concat(body.message);\n    return props;\n  }\n  if (body.error && body.error.description) {\n    props.message = body.error.description;\n    props.details = body.error;\n    return props;\n  }\n  props.message = body.error || body.message || httpErrorMessage(res);\n  return props;\n}\nfunction httpErrorMessage(res) {\n  const statusMessage = res.statusMessage ? \" \".concat(res.statusMessage) : \"\";\n  return \"\".concat(res.method, \"-request to \").concat(res.url, \" resulted in HTTP \").concat(res.statusCode).concat(statusMessage);\n}\nfunction stringifyBody(body, res) {\n  const contentType = (res.headers[\"content-type\"] || \"\").toLowerCase();\n  const isJson = contentType.indexOf(\"application/json\") !== -1;\n  return isJson ? JSON.stringify(body, null, 2) : body;\n}\nconst httpError = {\n  onResponse: res => {\n    if (res.statusCode >= 500) {\n      throw new ServerError(res);\n    } else if (res.statusCode >= 400) {\n      throw new ClientError(res);\n    }\n    return res;\n  }\n};\nconst printWarnings = {\n  onResponse: res => {\n    const warn = res.headers[\"x-sanity-warning\"];\n    const warnings = Array.isArray(warn) ? warn : [warn];\n    warnings.filter(Boolean).forEach(msg => console.warn(msg));\n    return res;\n  }\n};\nfunction defineHttpRequest(envMiddleware) {\n  const request = getIt([...envMiddleware, printWarnings, jsonRequest(), jsonResponse(), progress(), httpError, observable({\n    implementation: Observable\n  })]);\n  function httpRequest(options) {\n    let requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : request;\n    return requester({\n      maxRedirects: 0,\n      ...options\n    });\n  }\n  httpRequest.defaultRequester = request;\n  return httpRequest;\n}\nconst projectHeader = \"X-Sanity-Project-ID\";\nfunction requestOptions(config) {\n  let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const headers = {};\n  const token = overrides.token || config.token;\n  if (token) {\n    headers.Authorization = \"Bearer \".concat(token);\n  }\n  if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {\n    headers[projectHeader] = config.projectId;\n  }\n  const withCredentials = Boolean(typeof overrides.withCredentials === \"undefined\" ? config.token || config.withCredentials : overrides.withCredentials);\n  const timeout = typeof overrides.timeout === \"undefined\" ? config.timeout : overrides.timeout;\n  return Object.assign({}, overrides, {\n    headers: Object.assign({}, headers, overrides.headers || {}),\n    timeout: typeof timeout === \"undefined\" ? 5 * 60 * 1e3 : timeout,\n    proxy: overrides.proxy || config.proxy,\n    json: true,\n    withCredentials\n  });\n}\nfunction getSelection(sel) {\n  if (typeof sel === \"string\" || Array.isArray(sel)) {\n    return {\n      id: sel\n    };\n  }\n  if (typeof sel === \"object\" && sel !== null && \"query\" in sel && typeof sel.query === \"string\") {\n    return \"params\" in sel && typeof sel.params === \"object\" && sel.params !== null ? {\n      query: sel.query,\n      params: sel.params\n    } : {\n      query: sel.query\n    };\n  }\n  const selectionOpts = [\"* Document ID (<docId>)\", \"* Array of document IDs\", \"* Object containing `query`\"].join(\"\\n\");\n  throw new Error(\"Unknown selection - must be one of:\\n\\n\".concat(selectionOpts));\n}\nconst VALID_ASSET_TYPES = [\"image\", \"file\"];\nconst VALID_INSERT_LOCATIONS = [\"before\", \"after\", \"replace\"];\nconst dataset = name => {\n  if (!/^(~[a-z0-9]{1}[-\\w]{0,63}|[a-z0-9]{1}[-\\w]{0,63})$/.test(name)) {\n    throw new Error(\"Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters\");\n  }\n};\nconst projectId = id => {\n  if (!/^[-a-z0-9]+$/i.test(id)) {\n    throw new Error(\"`projectId` can only contain only a-z, 0-9 and dashes\");\n  }\n};\nconst validateAssetType = type => {\n  if (VALID_ASSET_TYPES.indexOf(type) === -1) {\n    throw new Error(\"Invalid asset type: \".concat(type, \". Must be one of \").concat(VALID_ASSET_TYPES.join(\", \")));\n  }\n};\nconst validateObject = (op, val) => {\n  if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n    throw new Error(\"\".concat(op, \"() takes an object of properties\"));\n  }\n};\nconst validateDocumentId = (op, id) => {\n  if (typeof id !== \"string\" || !/^[a-z0-9_.-]+$/i.test(id)) {\n    throw new Error(\"\".concat(op, \"(): \\\"\").concat(id, \"\\\" is not a valid document ID\"));\n  }\n};\nconst requireDocumentId = (op, doc) => {\n  if (!doc._id) {\n    throw new Error(\"\".concat(op, \"() requires that the document contains an ID (\\\"_id\\\" property)\"));\n  }\n  validateDocumentId(op, doc._id);\n};\nconst validateInsert = (at, selector, items) => {\n  const signature = \"insert(at, selector, items)\";\n  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {\n    const valid = VALID_INSERT_LOCATIONS.map(loc => \"\\\"\".concat(loc, \"\\\"\")).join(\", \");\n    throw new Error(\"\".concat(signature, \" takes an \\\"at\\\"-argument which is one of: \").concat(valid));\n  }\n  if (typeof selector !== \"string\") {\n    throw new Error(\"\".concat(signature, \" takes a \\\"selector\\\"-argument which must be a string\"));\n  }\n  if (!Array.isArray(items)) {\n    throw new Error(\"\".concat(signature, \" takes an \\\"items\\\"-argument which must be an array\"));\n  }\n};\nconst hasDataset = config => {\n  if (!config.dataset) {\n    throw new Error(\"`dataset` must be provided to perform queries\");\n  }\n  return config.dataset || \"\";\n};\nconst requestTag = tag => {\n  if (typeof tag !== \"string\" || !/^[a-z0-9._-]{1,75}$/i.test(tag)) {\n    throw new Error(\"Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.\");\n  }\n  return tag;\n};\nconst encodeQueryString = _ref => {\n  let {\n    query,\n    params = {},\n    options = {}\n  } = _ref;\n  const searchParams = new URLSearchParams();\n  const {\n    tag,\n    ...opts\n  } = options;\n  if (tag) searchParams.set(\"tag\", tag);\n  searchParams.set(\"query\", query);\n  for (const [key, value] of Object.entries(params)) {\n    searchParams.set(\"$\".concat(key), JSON.stringify(value));\n  }\n  for (const [key, value] of Object.entries(opts)) {\n    if (value) searchParams.set(key, \"\".concat(value));\n  }\n  return \"?\".concat(searchParams);\n};\nvar __accessCheck$6 = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$6 = (obj, member, getter) => {\n  __accessCheck$6(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$6 = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$6 = (obj, member, value, setter) => {\n  __accessCheck$6(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _client$5, _client2$5;\nclass BasePatch {\n  constructor(selection) {\n    let operations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.selection = selection;\n    this.operations = operations;\n  }\n  /**\n   * Sets the given attributes to the document. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  set(attrs) {\n    return this._assign(\"set\", attrs);\n  }\n  /**\n   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  setIfMissing(attrs) {\n    return this._assign(\"setIfMissing\", attrs);\n  }\n  /**\n   * Performs a \"diff-match-patch\" operation on the string attributes provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"dmp\"\\}\n   */\n  diffMatchPatch(attrs) {\n    validateObject(\"diffMatchPatch\", attrs);\n    return this._assign(\"diffMatchPatch\", attrs);\n  }\n  /**\n   * Unsets the attribute paths provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attribute paths to unset.\n   */\n  unset(attrs) {\n    if (!Array.isArray(attrs)) {\n      throw new Error(\"unset(attrs) takes an array of attributes to unset, non-array given\");\n    }\n    this.operations = Object.assign({}, this.operations, {\n      unset: attrs\n    });\n    return this;\n  }\n  /**\n   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.\n   */\n  inc(attrs) {\n    return this._assign(\"inc\", attrs);\n  }\n  /**\n   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.\n   */\n  dec(attrs) {\n    return this._assign(\"dec\", attrs);\n  }\n  /**\n   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.\n   *\n   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path\n   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key==\"abc123\"]`\n   * @param items - Array of items to insert/replace\n   */\n  insert(at, selector, items) {\n    validateInsert(at, selector, items);\n    return this._assign(\"insert\", {\n      [at]: selector,\n      items\n    });\n  }\n  /**\n   * Append the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to append to the array\n   */\n  append(selector, items) {\n    return this.insert(\"after\", \"\".concat(selector, \"[-1]\"), items);\n  }\n  /**\n   * Prepend the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to prepend to the array\n   */\n  prepend(selector, items) {\n    return this.insert(\"before\", \"\".concat(selector, \"[0]\"), items);\n  }\n  /**\n   * Change the contents of an array by removing existing elements and/or adding new elements.\n   *\n   * @param selector - Attribute or JSONPath expression for array\n   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x\n   * @param deleteCount - An integer indicating the number of old array elements to remove.\n   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.\n   */\n  splice(selector, start, deleteCount, items) {\n    const delAll = typeof deleteCount === \"undefined\" || deleteCount === -1;\n    const startIndex = start < 0 ? start - 1 : start;\n    const delCount = delAll ? -1 : Math.max(0, start + deleteCount);\n    const delRange = startIndex < 0 && delCount >= 0 ? \"\" : delCount;\n    const rangeSelector = \"\".concat(selector, \"[\").concat(startIndex, \":\").concat(delRange, \"]\");\n    return this.insert(\"replace\", rangeSelector, items || []);\n  }\n  /**\n   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value\n   *\n   * @param rev - Revision to lock the patch to\n   */\n  ifRevisionId(rev) {\n    this.operations.ifRevisionID = rev;\n    return this;\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  serialize() {\n    return {\n      ...getSelection(this.selection),\n      ...this.operations\n    };\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the patch of all operations\n   */\n  reset() {\n    this.operations = {};\n    return this;\n  }\n  _assign(op, props) {\n    let merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    validateObject(op, props);\n    this.operations = Object.assign({}, this.operations, {\n      [op]: Object.assign({}, merge && this.operations[op] || {}, props)\n    });\n    return this;\n  }\n  _set(op, props) {\n    return this._assign(op, props, false);\n  }\n}\nconst _ObservablePatch = class extends BasePatch {\n  constructor(selection, operations, client) {\n    super(selection, operations);\n    __privateAdd$6(this, _client$5, void 0);\n    __privateSet$6(this, _client$5, client);\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new _ObservablePatch(this.selection, {\n      ...this.operations\n    }, __privateGet$6(this, _client$5));\n  }\n  commit(options) {\n    if (!__privateGet$6(this, _client$5)) {\n      throw new Error(\"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\");\n    }\n    const returnFirst = typeof this.selection === \"string\";\n    const opts = Object.assign({\n      returnFirst,\n      returnDocuments: true\n    }, options);\n    return __privateGet$6(this, _client$5).mutate({\n      patch: this.serialize()\n    }, opts);\n  }\n};\nlet ObservablePatch = _ObservablePatch;\n_client$5 = new WeakMap();\nconst _Patch = class extends BasePatch {\n  constructor(selection, operations, client) {\n    super(selection, operations);\n    __privateAdd$6(this, _client2$5, void 0);\n    __privateSet$6(this, _client2$5, client);\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new _Patch(this.selection, {\n      ...this.operations\n    }, __privateGet$6(this, _client2$5));\n  }\n  commit(options) {\n    if (!__privateGet$6(this, _client2$5)) {\n      throw new Error(\"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\");\n    }\n    const returnFirst = typeof this.selection === \"string\";\n    const opts = Object.assign({\n      returnFirst,\n      returnDocuments: true\n    }, options);\n    return __privateGet$6(this, _client2$5).mutate({\n      patch: this.serialize()\n    }, opts);\n  }\n};\nlet Patch = _Patch;\n_client2$5 = new WeakMap();\nvar __accessCheck$5 = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$5 = (obj, member, getter) => {\n  __accessCheck$5(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$5 = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$5 = (obj, member, value, setter) => {\n  __accessCheck$5(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _client$4, _client2$4;\nconst defaultMutateOptions = {\n  returnDocuments: false\n};\nclass BaseTransaction {\n  constructor() {\n    let operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let transactionId = arguments.length > 1 ? arguments[1] : undefined;\n    this.operations = operations;\n    this.trxId = transactionId;\n  }\n  /**\n   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create. Requires a `_type` property.\n   */\n  create(doc) {\n    validateObject(\"create\", doc);\n    return this._add({\n      create: doc\n    });\n  }\n  /**\n   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.\n   */\n  createIfNotExists(doc) {\n    const op = \"createIfNotExists\";\n    validateObject(op, doc);\n    requireDocumentId(op, doc);\n    return this._add({\n      [op]: doc\n    });\n  }\n  /**\n   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.\n   */\n  createOrReplace(doc) {\n    const op = \"createOrReplace\";\n    validateObject(op, doc);\n    requireDocumentId(op, doc);\n    return this._add({\n      [op]: doc\n    });\n  }\n  /**\n   * Deletes the document with the given document ID\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to delete\n   */\n  delete(documentId) {\n    validateDocumentId(\"delete\", documentId);\n    return this._add({\n      delete: {\n        id: documentId\n      }\n    });\n  }\n  transactionId(id) {\n    if (!id) {\n      return this.trxId;\n    }\n    this.trxId = id;\n    return this;\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  serialize() {\n    return [...this.operations];\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the transaction of all operations\n   */\n  reset() {\n    this.operations = [];\n    return this;\n  }\n  _add(mut) {\n    this.operations.push(mut);\n    return this;\n  }\n}\nconst _Transaction = class extends BaseTransaction {\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId);\n    __privateAdd$5(this, _client$4, void 0);\n    __privateSet$5(this, _client$4, client);\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new _Transaction([...this.operations], __privateGet$5(this, _client$4), this.trxId);\n  }\n  commit(options) {\n    if (!__privateGet$5(this, _client$4)) {\n      throw new Error(\"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\");\n    }\n    return __privateGet$5(this, _client$4).mutate(this.serialize(), Object.assign({\n      transactionId: this.trxId\n    }, defaultMutateOptions, options || {}));\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps === \"function\";\n    const isPatch = typeof patchOrDocumentId !== \"string\" && patchOrDocumentId instanceof Patch;\n    if (isPatch) {\n      return this._add({\n        patch: patchOrDocumentId.serialize()\n      });\n    }\n    if (isBuilder) {\n      const patch = patchOps(new Patch(patchOrDocumentId, {}, __privateGet$5(this, _client$4)));\n      if (!(patch instanceof Patch)) {\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      }\n      return this._add({\n        patch: patch.serialize()\n      });\n    }\n    return this._add({\n      patch: {\n        id: patchOrDocumentId,\n        ...patchOps\n      }\n    });\n  }\n};\nlet Transaction = _Transaction;\n_client$4 = new WeakMap();\nconst _ObservableTransaction = class extends BaseTransaction {\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId);\n    __privateAdd$5(this, _client2$4, void 0);\n    __privateSet$5(this, _client2$4, client);\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new _ObservableTransaction([...this.operations], __privateGet$5(this, _client2$4), this.trxId);\n  }\n  commit(options) {\n    if (!__privateGet$5(this, _client2$4)) {\n      throw new Error(\"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\");\n    }\n    return __privateGet$5(this, _client2$4).mutate(this.serialize(), Object.assign({\n      transactionId: this.trxId\n    }, defaultMutateOptions, options || {}));\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps === \"function\";\n    const isPatch = typeof patchOrDocumentId !== \"string\" && patchOrDocumentId instanceof ObservablePatch;\n    if (isPatch) {\n      return this._add({\n        patch: patchOrDocumentId.serialize()\n      });\n    }\n    if (isBuilder) {\n      const patch = patchOps(new ObservablePatch(patchOrDocumentId, {}, __privateGet$5(this, _client2$4)));\n      if (!(patch instanceof ObservablePatch)) {\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      }\n      return this._add({\n        patch: patch.serialize()\n      });\n    }\n    return this._add({\n      patch: {\n        id: patchOrDocumentId,\n        ...patchOps\n      }\n    });\n  }\n};\nlet ObservableTransaction = _ObservableTransaction;\n_client2$4 = new WeakMap();\nconst excludeFalsey = (param, defValue) => {\n  const value = typeof param === \"undefined\" ? defValue : param;\n  return param === false ? void 0 : value;\n};\nconst getMutationQuery = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    dryRun: options.dryRun,\n    returnIds: true,\n    returnDocuments: excludeFalsey(options.returnDocuments, true),\n    visibility: options.visibility || \"sync\",\n    autoGenerateArrayKeys: options.autoGenerateArrayKeys,\n    skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation\n  };\n};\nconst isResponse = event => event.type === \"response\";\nconst getBody = event => event.body;\nconst indexBy = (docs, attr) => docs.reduce((indexed, doc) => {\n  indexed[attr(doc)] = doc;\n  return indexed;\n}, /* @__PURE__ */Object.create(null));\nconst getQuerySizeLimit = 11264;\nfunction _fetch(client, httpRequest, query, params) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const mapResponse = options.filterResponse === false ? res => res : res => res.result;\n  return _dataRequest(client, httpRequest, \"query\", {\n    query,\n    params\n  }, options).pipe(map(mapResponse));\n}\nfunction _getDocument(client, httpRequest, id) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const options = {\n    uri: _getDataUrl(client, \"doc\", id),\n    json: true,\n    tag: opts.tag\n  };\n  return _requestObservable(client, httpRequest, options).pipe(filter(isResponse), map(event => event.body.documents && event.body.documents[0]));\n}\nfunction _getDocuments(client, httpRequest, ids) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const options = {\n    uri: _getDataUrl(client, \"doc\", ids.join(\",\")),\n    json: true,\n    tag: opts.tag\n  };\n  return _requestObservable(client, httpRequest, options).pipe(filter(isResponse), map(event => {\n    const indexed = indexBy(event.body.documents || [], doc => doc._id);\n    return ids.map(id => indexed[id] || null);\n  }));\n}\nfunction _createIfNotExists(client, httpRequest, doc, options) {\n  requireDocumentId(\"createIfNotExists\", doc);\n  return _create(client, httpRequest, doc, \"createIfNotExists\", options);\n}\nfunction _createOrReplace(client, httpRequest, doc, options) {\n  requireDocumentId(\"createOrReplace\", doc);\n  return _create(client, httpRequest, doc, \"createOrReplace\", options);\n}\nfunction _delete(client, httpRequest, selection, options) {\n  return _dataRequest(client, httpRequest, \"mutate\", {\n    mutations: [{\n      delete: getSelection(selection)\n    }]\n  }, options);\n}\nfunction _mutate(client, httpRequest, mutations, options) {\n  const mut = mutations instanceof Patch || mutations instanceof ObservablePatch || mutations instanceof Transaction || mutations instanceof ObservableTransaction ? mutations.serialize() : mutations;\n  const muts = Array.isArray(mut) ? mut : [mut];\n  const transactionId = options && options.transactionId;\n  return _dataRequest(client, httpRequest, \"mutate\", {\n    mutations: muts,\n    transactionId\n  }, options);\n}\nfunction _dataRequest(client, httpRequest, endpoint, body) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const isMutation = endpoint === \"mutate\";\n  const isQuery = endpoint === \"query\";\n  const strQuery = isMutation ? \"\" : encodeQueryString(body);\n  const useGet = !isMutation && strQuery.length < getQuerySizeLimit;\n  const stringQuery = useGet ? strQuery : \"\";\n  const returnFirst = options.returnFirst;\n  const {\n    timeout,\n    token,\n    tag,\n    headers\n  } = options;\n  const uri = _getDataUrl(client, endpoint, stringQuery);\n  const reqOptions = {\n    method: useGet ? \"GET\" : \"POST\",\n    uri,\n    json: true,\n    body: useGet ? void 0 : body,\n    query: isMutation && getMutationQuery(options),\n    timeout,\n    headers,\n    token,\n    tag,\n    canUseCdn: isQuery,\n    signal: options.signal\n  };\n  return _requestObservable(client, httpRequest, reqOptions).pipe(filter(isResponse), map(getBody), map(res => {\n    if (!isMutation) {\n      return res;\n    }\n    const results = res.results || [];\n    if (options.returnDocuments) {\n      return returnFirst ? results[0] && results[0].document : results.map(mut => mut.document);\n    }\n    const key = returnFirst ? \"documentId\" : \"documentIds\";\n    const ids = returnFirst ? results[0] && results[0].id : results.map(mut => mut.id);\n    return {\n      transactionId: res.transactionId,\n      results,\n      [key]: ids\n    };\n  }));\n}\nfunction _create(client, httpRequest, doc, op) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const mutation = {\n    [op]: doc\n  };\n  const opts = Object.assign({\n    returnFirst: true,\n    returnDocuments: true\n  }, options);\n  return _dataRequest(client, httpRequest, \"mutate\", {\n    mutations: [mutation]\n  }, opts);\n}\nfunction _requestObservable(client, httpRequest, options) {\n  const uri = options.url || options.uri;\n  const config = client.config();\n  const canUseCdn = typeof options.canUseCdn === \"undefined\" ? [\"GET\", \"HEAD\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/\") === 0 : options.canUseCdn;\n  const useCdn = config.useCdn && canUseCdn;\n  const tag = options.tag && config.requestTagPrefix ? [config.requestTagPrefix, options.tag].join(\".\") : options.tag || config.requestTagPrefix;\n  if (tag) {\n    options.query = {\n      tag: requestTag(tag),\n      ...options.query\n    };\n  }\n  const reqOptions = requestOptions(config, Object.assign({}, options, {\n    url: _getUrl(client, uri, useCdn)\n  }));\n  const request = new Observable(subscriber =>\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the typings thinks it's optional because it's not required to specify it when calling createClient, but it's always defined in practice since SanityClient provides a default\n  httpRequest(reqOptions, config.requester).subscribe(subscriber));\n  return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request;\n}\nfunction _request(client, httpRequest, options) {\n  const observable = _requestObservable(client, httpRequest, options).pipe(filter(event => event.type === \"response\"), map(event => event.body));\n  return observable;\n}\nfunction _getDataUrl(client, operation, path) {\n  const config = client.config();\n  const catalog = hasDataset(config);\n  const baseUri = \"/\".concat(operation, \"/\").concat(catalog);\n  const uri = path ? \"\".concat(baseUri, \"/\").concat(path) : baseUri;\n  return \"/data\".concat(uri).replace(/\\/($|\\?)/, \"$1\");\n}\nfunction _getUrl(client, uri) {\n  let canUseCdn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const {\n    url,\n    cdnUrl\n  } = client.config();\n  const base = canUseCdn ? cdnUrl : url;\n  return \"\".concat(base, \"/\").concat(uri.replace(/^\\//, \"\"));\n}\nfunction _withAbortSignal(signal) {\n  return input => {\n    return new Observable(observer => {\n      const abort = () => observer.error(_createAbortError(signal));\n      if (signal && signal.aborted) {\n        abort();\n        return;\n      }\n      const subscription = input.subscribe(observer);\n      signal.addEventListener(\"abort\", abort);\n      return () => {\n        signal.removeEventListener(\"abort\", abort);\n        subscription.unsubscribe();\n      };\n    });\n  };\n}\nconst isDomExceptionSupported = Boolean(globalThis.DOMException);\nfunction _createAbortError(signal) {\n  var _a, _b;\n  if (isDomExceptionSupported) {\n    return new DOMException((_a = signal == null ? void 0 : signal.reason) != null ? _a : \"The operation was aborted.\", \"AbortError\");\n  }\n  const error = new Error((_b = signal == null ? void 0 : signal.reason) != null ? _b : \"The operation was aborted.\");\n  error.name = \"AbortError\";\n  return error;\n}\nvar __accessCheck$4 = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$4 = (obj, member, getter) => {\n  __accessCheck$4(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$4 = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$4 = (obj, member, value, setter) => {\n  __accessCheck$4(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _client$3, _httpRequest$4, _client2$3, _httpRequest2$4;\nclass ObservableAssetsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$4(this, _client$3, void 0);\n    __privateAdd$4(this, _httpRequest$4, void 0);\n    __privateSet$4(this, _client$3, client);\n    __privateSet$4(this, _httpRequest$4, httpRequest);\n  }\n  upload(assetType, body, options) {\n    return _upload(__privateGet$4(this, _client$3), __privateGet$4(this, _httpRequest$4), assetType, body, options);\n  }\n}\n_client$3 = new WeakMap();\n_httpRequest$4 = new WeakMap();\nclass AssetsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$4(this, _client2$3, void 0);\n    __privateAdd$4(this, _httpRequest2$4, void 0);\n    __privateSet$4(this, _client2$3, client);\n    __privateSet$4(this, _httpRequest2$4, httpRequest);\n  }\n  upload(assetType, body, options) {\n    const observable = _upload(__privateGet$4(this, _client2$3), __privateGet$4(this, _httpRequest2$4), assetType, body, options);\n    return lastValueFrom(observable.pipe(filter(event => event.type === \"response\"), map(event => event.body.document)));\n  }\n}\n_client2$3 = new WeakMap();\n_httpRequest2$4 = new WeakMap();\nfunction _upload(client, httpRequest, assetType, body) {\n  let opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  validateAssetType(assetType);\n  let meta = opts.extract || void 0;\n  if (meta && !meta.length) {\n    meta = [\"none\"];\n  }\n  const dataset = hasDataset(client.config());\n  const assetEndpoint = assetType === \"image\" ? \"images\" : \"files\";\n  const options = optionsFromFile(opts, body);\n  const {\n    tag,\n    label,\n    title,\n    description,\n    creditLine,\n    filename,\n    source\n  } = options;\n  const query = {\n    label,\n    title,\n    description,\n    filename,\n    meta,\n    creditLine\n  };\n  if (source) {\n    query.sourceId = source.id;\n    query.sourceName = source.name;\n    query.sourceUrl = source.url;\n  }\n  return _requestObservable(client, httpRequest, {\n    tag,\n    method: \"POST\",\n    timeout: options.timeout || 0,\n    uri: \"/assets/\".concat(assetEndpoint, \"/\").concat(dataset),\n    headers: options.contentType ? {\n      \"Content-Type\": options.contentType\n    } : {},\n    query,\n    body\n  });\n}\nfunction optionsFromFile(opts, file) {\n  if (typeof window === \"undefined\" || !(file instanceof window.File)) {\n    return opts;\n  }\n  return Object.assign({\n    filename: opts.preserveFilename === false ? void 0 : file.name,\n    contentType: file.type\n  }, opts);\n}\nconst BASE_URL = \"https://www.sanity.io/help/\";\nfunction generateHelpUrl(slug) {\n  return BASE_URL + slug;\n}\nfunction once(fn) {\n  let didCall = false;\n  let returnValue;\n  return function () {\n    if (didCall) {\n      return returnValue;\n    }\n    returnValue = fn(...arguments);\n    didCall = true;\n    return returnValue;\n  };\n}\nconst createWarningPrinter = message =>\n// eslint-disable-next-line no-console\nonce(function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return console.warn(message.join(\" \"), ...args);\n});\nconst printCdnWarning = createWarningPrinter([\"You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and\", \"cheaper. Think about it! For more info, see \".concat(generateHelpUrl(\"js-client-cdn-configuration\"), \" \"), \"To hide this warning, please set the `useCdn` option to either `true` or `false` when creating\", \"the client.\"]);\nconst printBrowserTokenWarning = createWarningPrinter([\"You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.\", \"See \".concat(generateHelpUrl(\"js-client-browser-token\"), \" for more information and how to hide this warning.\")]);\nconst printNoApiVersionSpecifiedWarning = createWarningPrinter([\"Using the Sanity client without specifying an API version is deprecated.\", \"See \".concat(generateHelpUrl(\"js-client-api-version\"))]);\nconst printNoDefaultExport = createWarningPrinter([\"The default export of @sanity/client has been deprecated. Use the named export `createClient` instead\"]);\nconst defaultCdnHost = \"apicdn.sanity.io\";\nconst defaultConfig = {\n  apiHost: \"https://api.sanity.io\",\n  apiVersion: \"1\",\n  useProjectHostname: true\n};\nconst LOCALHOSTS = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"];\nconst isLocal = host => LOCALHOSTS.indexOf(host) !== -1;\nconst validateApiVersion = function validateApiVersion2(apiVersion) {\n  if (apiVersion === \"1\" || apiVersion === \"X\") {\n    return;\n  }\n  const apiDate = new Date(apiVersion);\n  const apiVersionValid = /^\\d{4}-\\d{2}-\\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0;\n  if (!apiVersionValid) {\n    throw new Error(\"Invalid API version string, expected `1` or date in format `YYYY-MM-DD`\");\n  }\n};\nconst initConfig = (config, prevConfig) => {\n  const specifiedConfig = Object.assign({}, prevConfig, config);\n  if (!specifiedConfig.apiVersion) {\n    printNoApiVersionSpecifiedWarning();\n  }\n  const newConfig = Object.assign({}, defaultConfig, specifiedConfig);\n  const projectBased = newConfig.useProjectHostname;\n  if (typeof Promise === \"undefined\") {\n    const helpUrl = generateHelpUrl(\"js-client-promise-polyfill\");\n    throw new Error(\"No native Promise-implementation found, polyfill needed - see \".concat(helpUrl));\n  }\n  if (projectBased && !newConfig.projectId) {\n    throw new Error(\"Configuration must contain `projectId`\");\n  }\n  const isBrowser = typeof window !== \"undefined\" && window.location && window.location.hostname;\n  const isLocalhost = isBrowser && isLocal(window.location.hostname);\n  if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {\n    printBrowserTokenWarning();\n  } else if (typeof newConfig.useCdn === \"undefined\") {\n    printCdnWarning();\n  }\n  if (projectBased) {\n    projectId(newConfig.projectId);\n  }\n  if (newConfig.dataset) {\n    dataset(newConfig.dataset);\n  }\n  if (\"requestTagPrefix\" in newConfig) {\n    newConfig.requestTagPrefix = newConfig.requestTagPrefix ? requestTag(newConfig.requestTagPrefix).replace(/\\.+$/, \"\") : void 0;\n  }\n  newConfig.apiVersion = \"\".concat(newConfig.apiVersion).replace(/^v/, \"\");\n  newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost;\n  newConfig.useCdn = Boolean(newConfig.useCdn) && !newConfig.withCredentials;\n  validateApiVersion(newConfig.apiVersion);\n  const hostParts = newConfig.apiHost.split(\"://\", 2);\n  const protocol = hostParts[0];\n  const host = hostParts[1];\n  const cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;\n  if (newConfig.useProjectHostname) {\n    newConfig.url = \"\".concat(protocol, \"://\").concat(newConfig.projectId, \".\").concat(host, \"/v\").concat(newConfig.apiVersion);\n    newConfig.cdnUrl = \"\".concat(protocol, \"://\").concat(newConfig.projectId, \".\").concat(cdnHost, \"/v\").concat(newConfig.apiVersion);\n  } else {\n    newConfig.url = \"\".concat(newConfig.apiHost, \"/v\").concat(newConfig.apiVersion);\n    newConfig.cdnUrl = newConfig.url;\n  }\n  return newConfig;\n};\nvar defaults = (obj, defaults) => Object.keys(defaults).concat(Object.keys(obj)).reduce((target, prop) => {\n  target[prop] = typeof obj[prop] === \"undefined\" ? defaults[prop] : obj[prop];\n  return target;\n}, {});\nconst pick = (obj, props) => props.reduce((selection, prop) => {\n  if (typeof obj[prop] === \"undefined\") {\n    return selection;\n  }\n  selection[prop] = obj[prop];\n  return selection;\n}, {});\nconst MAX_URL_LENGTH = 16e3 - 1200;\nconst EventSource = polyfilledEventSource;\nconst possibleOptions = [\"includePreviousRevision\", \"includeResult\", \"visibility\", \"effectFormat\", \"tag\"];\nconst defaultOptions = {\n  includeResult: true\n};\nfunction _listen(query, params) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    url,\n    token,\n    withCredentials,\n    requestTagPrefix\n  } = this.config();\n  const tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join(\".\") : opts.tag;\n  const options = {\n    ...defaults(opts, defaultOptions),\n    tag\n  };\n  const listenOpts = pick(options, possibleOptions);\n  const qs = encodeQueryString({\n    query,\n    params,\n    options: {\n      tag,\n      ...listenOpts\n    }\n  });\n  const uri = \"\".concat(url).concat(_getDataUrl(this, \"listen\", qs));\n  if (uri.length > MAX_URL_LENGTH) {\n    return new Observable(observer => observer.error(new Error(\"Query too large for listener\")));\n  }\n  const listenFor = options.events ? options.events : [\"mutation\"];\n  const shouldEmitReconnect = listenFor.indexOf(\"reconnect\") !== -1;\n  const esOptions = {};\n  if (token || withCredentials) {\n    esOptions.withCredentials = true;\n  }\n  if (token) {\n    esOptions.headers = {\n      Authorization: \"Bearer \".concat(token)\n    };\n  }\n  return new Observable(observer => {\n    let es = getEventSource();\n    let reconnectTimer;\n    let stopped = false;\n    function onError() {\n      if (stopped) {\n        return;\n      }\n      emitReconnect();\n      if (stopped) {\n        return;\n      }\n      if (es.readyState === EventSource.CLOSED) {\n        unsubscribe();\n        clearTimeout(reconnectTimer);\n        reconnectTimer = setTimeout(open, 100);\n      }\n    }\n    function onChannelError(err) {\n      observer.error(cooerceError(err));\n    }\n    function onMessage(evt) {\n      const event = parseEvent(evt);\n      return event instanceof Error ? observer.error(event) : observer.next(event);\n    }\n    function onDisconnect() {\n      stopped = true;\n      unsubscribe();\n      observer.complete();\n    }\n    function unsubscribe() {\n      es.removeEventListener(\"error\", onError, false);\n      es.removeEventListener(\"channelError\", onChannelError, false);\n      es.removeEventListener(\"disconnect\", onDisconnect, false);\n      listenFor.forEach(type => es.removeEventListener(type, onMessage, false));\n      es.close();\n    }\n    function emitReconnect() {\n      if (shouldEmitReconnect) {\n        observer.next({\n          type: \"reconnect\"\n        });\n      }\n    }\n    function getEventSource() {\n      const evs = new EventSource(uri, esOptions);\n      evs.addEventListener(\"error\", onError, false);\n      evs.addEventListener(\"channelError\", onChannelError, false);\n      evs.addEventListener(\"disconnect\", onDisconnect, false);\n      listenFor.forEach(type => evs.addEventListener(type, onMessage, false));\n      return evs;\n    }\n    function open() {\n      es = getEventSource();\n    }\n    function stop() {\n      stopped = true;\n      unsubscribe();\n    }\n    return stop;\n  });\n}\nfunction parseEvent(event) {\n  try {\n    const data = event.data && JSON.parse(event.data) || {};\n    return Object.assign({\n      type: event.type\n    }, data);\n  } catch (err) {\n    return err;\n  }\n}\nfunction cooerceError(err) {\n  if (err instanceof Error) {\n    return err;\n  }\n  const evt = parseEvent(err);\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\nfunction extractErrorMessage(err) {\n  if (!err.error) {\n    return err.message || \"Unknown listener error\";\n  }\n  if (err.error.description) {\n    return err.error.description;\n  }\n  return typeof err.error === \"string\" ? err.error : JSON.stringify(err.error, null, 2);\n}\nvar __accessCheck$3 = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$3 = (obj, member, getter) => {\n  __accessCheck$3(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$3 = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$3 = (obj, member, value, setter) => {\n  __accessCheck$3(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _client$2, _httpRequest$3, _client2$2, _httpRequest2$3;\nclass ObservableDatasetsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$3(this, _client$2, void 0);\n    __privateAdd$3(this, _httpRequest$3, void 0);\n    __privateSet$3(this, _client$2, client);\n    __privateSet$3(this, _httpRequest$3, httpRequest);\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name, options) {\n    return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), \"PUT\", name, options);\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name, options) {\n    return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), \"PATCH\", name, options);\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name) {\n    return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), \"DELETE\", name);\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return _request(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), {\n      uri: \"/datasets\"\n    });\n  }\n}\n_client$2 = new WeakMap();\n_httpRequest$3 = new WeakMap();\nclass DatasetsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$3(this, _client2$2, void 0);\n    __privateAdd$3(this, _httpRequest2$3, void 0);\n    __privateSet$3(this, _client2$2, client);\n    __privateSet$3(this, _httpRequest2$3, httpRequest);\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name, options) {\n    return lastValueFrom(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), \"PUT\", name, options));\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name, options) {\n    return lastValueFrom(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), \"PATCH\", name, options));\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name) {\n    return lastValueFrom(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), \"DELETE\", name));\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return lastValueFrom(_request(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), {\n      uri: \"/datasets\"\n    }));\n  }\n}\n_client2$2 = new WeakMap();\n_httpRequest2$3 = new WeakMap();\nfunction _modify(client, httpRequest, method, name, options) {\n  dataset(name);\n  return _request(client, httpRequest, {\n    method,\n    uri: \"/datasets/\".concat(name),\n    body: options\n  });\n}\nvar __accessCheck$2 = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$2 = (obj, member, getter) => {\n  __accessCheck$2(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$2 = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$2 = (obj, member, value, setter) => {\n  __accessCheck$2(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _client$1, _httpRequest$2, _client2$1, _httpRequest2$2;\nclass ObservableProjectsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$2(this, _client$1, void 0);\n    __privateAdd$2(this, _httpRequest$2, void 0);\n    __privateSet$2(this, _client$1, client);\n    __privateSet$2(this, _httpRequest$2, httpRequest);\n  }\n  /**\n   * Fetch a list of projects the authenticated user has access to\n   */\n  list() {\n    return _request(__privateGet$2(this, _client$1), __privateGet$2(this, _httpRequest$2), {\n      uri: \"/projects\"\n    });\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId) {\n    return _request(__privateGet$2(this, _client$1), __privateGet$2(this, _httpRequest$2), {\n      uri: \"/projects/\".concat(projectId)\n    });\n  }\n}\n_client$1 = new WeakMap();\n_httpRequest$2 = new WeakMap();\nclass ProjectsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$2(this, _client2$1, void 0);\n    __privateAdd$2(this, _httpRequest2$2, void 0);\n    __privateSet$2(this, _client2$1, client);\n    __privateSet$2(this, _httpRequest2$2, httpRequest);\n  }\n  /**\n   * Fetch a list of projects the authenticated user has access to\n   */\n  list() {\n    return lastValueFrom(_request(__privateGet$2(this, _client2$1), __privateGet$2(this, _httpRequest2$2), {\n      uri: \"/projects\"\n    }));\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId) {\n    return lastValueFrom(_request(__privateGet$2(this, _client2$1), __privateGet$2(this, _httpRequest2$2), {\n      uri: \"/projects/\".concat(projectId)\n    }));\n  }\n}\n_client2$1 = new WeakMap();\n_httpRequest2$2 = new WeakMap();\nvar __accessCheck$1 = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$1 = (obj, member, getter) => {\n  __accessCheck$1(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$1 = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$1 = (obj, member, value, setter) => {\n  __accessCheck$1(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _client, _httpRequest$1, _client2, _httpRequest2$1;\nclass ObservableUsersClient {\n  constructor(client, httpRequest) {\n    __privateAdd$1(this, _client, void 0);\n    __privateAdd$1(this, _httpRequest$1, void 0);\n    __privateSet$1(this, _client, client);\n    __privateSet$1(this, _httpRequest$1, httpRequest);\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return _request(__privateGet$1(this, _client), __privateGet$1(this, _httpRequest$1), {\n      uri: \"/users/\".concat(id)\n    });\n  }\n}\n_client = new WeakMap();\n_httpRequest$1 = new WeakMap();\nclass UsersClient {\n  constructor(client, httpRequest) {\n    __privateAdd$1(this, _client2, void 0);\n    __privateAdd$1(this, _httpRequest2$1, void 0);\n    __privateSet$1(this, _client2, client);\n    __privateSet$1(this, _httpRequest2$1, httpRequest);\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return lastValueFrom(_request(__privateGet$1(this, _client2), __privateGet$1(this, _httpRequest2$1), {\n      uri: \"/users/\".concat(id)\n    }));\n  }\n}\n_client2 = new WeakMap();\n_httpRequest2$1 = new WeakMap();\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _clientConfig, _httpRequest, _clientConfig2, _httpRequest2;\nconst _ObservableSanityClient = class {\n  constructor(httpRequest) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConfig;\n    /**\n     * Private properties\n     */\n    __privateAdd(this, _clientConfig, void 0);\n    __privateAdd(this, _httpRequest, void 0);\n    /**\n     * Instance properties\n     */\n    this.listen = _listen;\n    this.config(config);\n    __privateSet(this, _httpRequest, httpRequest);\n    this.assets = new ObservableAssetsClient(this, __privateGet(this, _httpRequest));\n    this.datasets = new ObservableDatasetsClient(this, __privateGet(this, _httpRequest));\n    this.projects = new ObservableProjectsClient(this, __privateGet(this, _httpRequest));\n    this.users = new ObservableUsersClient(this, __privateGet(this, _httpRequest));\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new _ObservableSanityClient(__privateGet(this, _httpRequest), this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0) {\n      return {\n        ...__privateGet(this, _clientConfig)\n      };\n    }\n    if (__privateGet(this, _clientConfig) && __privateGet(this, _clientConfig).allowReconfigure === false) {\n      throw new Error(\"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\");\n    }\n    __privateSet(this, _clientConfig, initConfig(newConfig, __privateGet(this, _clientConfig) || {}));\n    return this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    return new _ObservableSanityClient(__privateGet(this, _httpRequest), {\n      ...this.config(),\n      ...newConfig\n    });\n  }\n  fetch(query, params) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return _fetch(this, __privateGet(this, _httpRequest), query, params, options);\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return _getDocument(this, __privateGet(this, _httpRequest), id, options);\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return _getDocuments(this, __privateGet(this, _httpRequest), ids, options);\n  }\n  create(document, options) {\n    return _create(this, __privateGet(this, _httpRequest), document, \"create\", options);\n  }\n  createIfNotExists(document, options) {\n    return _createIfNotExists(this, __privateGet(this, _httpRequest), document, options);\n  }\n  createOrReplace(document, options) {\n    return _createOrReplace(this, __privateGet(this, _httpRequest), document, options);\n  }\n  delete(selection, options) {\n    return _delete(this, __privateGet(this, _httpRequest), selection, options);\n  }\n  mutate(operations, options) {\n    return _mutate(this, __privateGet(this, _httpRequest), operations, options);\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param documentId - Document ID(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   */\n  patch(documentId, operations) {\n    return new ObservablePatch(documentId, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new ObservableTransaction(operations, this);\n  }\n  /**\n   * DEPRECATED: Perform an HTTP request against the Sanity API\n   *\n   * @deprecated Use your own request library!\n   * @param options - Request options\n   */\n  request(options) {\n    return _request(this, __privateGet(this, _httpRequest), options);\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n};\nlet ObservableSanityClient = _ObservableSanityClient;\n_clientConfig = new WeakMap();\n_httpRequest = new WeakMap();\nconst _SanityClient = class {\n  constructor(httpRequest) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConfig;\n    /**\n     * Private properties\n     */\n    __privateAdd(this, _clientConfig2, void 0);\n    __privateAdd(this, _httpRequest2, void 0);\n    /**\n     * Instance properties\n     */\n    this.listen = _listen;\n    this.config(config);\n    __privateSet(this, _httpRequest2, httpRequest);\n    this.assets = new AssetsClient(this, __privateGet(this, _httpRequest2));\n    this.datasets = new DatasetsClient(this, __privateGet(this, _httpRequest2));\n    this.projects = new ProjectsClient(this, __privateGet(this, _httpRequest2));\n    this.users = new UsersClient(this, __privateGet(this, _httpRequest2));\n    this.observable = new ObservableSanityClient(httpRequest, config);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new _SanityClient(__privateGet(this, _httpRequest2), this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0) {\n      return {\n        ...__privateGet(this, _clientConfig2)\n      };\n    }\n    if (__privateGet(this, _clientConfig2) && __privateGet(this, _clientConfig2).allowReconfigure === false) {\n      throw new Error(\"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\");\n    }\n    if (this.observable) {\n      this.observable.config(newConfig);\n    }\n    __privateSet(this, _clientConfig2, initConfig(newConfig, __privateGet(this, _clientConfig2) || {}));\n    return this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    return new _SanityClient(__privateGet(this, _httpRequest2), {\n      ...this.config(),\n      ...newConfig\n    });\n  }\n  fetch(query, params) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return lastValueFrom(_fetch(this, __privateGet(this, _httpRequest2), query, params, options));\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return lastValueFrom(_getDocument(this, __privateGet(this, _httpRequest2), id, options));\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return lastValueFrom(_getDocuments(this, __privateGet(this, _httpRequest2), ids, options));\n  }\n  create(document, options) {\n    return lastValueFrom(_create(this, __privateGet(this, _httpRequest2), document, \"create\", options));\n  }\n  createIfNotExists(document, options) {\n    return lastValueFrom(_createIfNotExists(this, __privateGet(this, _httpRequest2), document, options));\n  }\n  createOrReplace(document, options) {\n    return lastValueFrom(_createOrReplace(this, __privateGet(this, _httpRequest2), document, options));\n  }\n  delete(selection, options) {\n    return lastValueFrom(_delete(this, __privateGet(this, _httpRequest2), selection, options));\n  }\n  mutate(operations, options) {\n    return lastValueFrom(_mutate(this, __privateGet(this, _httpRequest2), operations, options));\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param documentId - Document ID(s)to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   */\n  patch(documentId, operations) {\n    return new Patch(documentId, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new Transaction(operations, this);\n  }\n  /**\n   * DEPRECATED: Perform an HTTP request against the Sanity API\n   *\n   * @deprecated Use your own request library!\n   * @param options - Request options\n   */\n  request(options) {\n    return lastValueFrom(_request(this, __privateGet(this, _httpRequest2), options));\n  }\n  /**\n   * DEPRECATED: Perform an HTTP request a `/data` sub-endpoint\n   *\n   * @deprecated Use your own request library!\n   * @param endpoint - Endpoint to hit (mutate, query etc)\n   * @param body - Request body\n   * @param options - Request options\n   */\n  dataRequest(endpoint, body, options) {\n    return lastValueFrom(_dataRequest(this, __privateGet(this, _httpRequest2), endpoint, body, options));\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n};\nlet SanityClient = _SanityClient;\n_clientConfig2 = new WeakMap();\n_httpRequest2 = new WeakMap();\nconst httpRequest = defineHttpRequest(envMiddleware);\nconst requester = httpRequest.defaultRequester;\nconst createClient = config => new SanityClient(httpRequest, config);\nfunction deprecatedCreateClient(config) {\n  printNoDefaultExport();\n  return new SanityClient(httpRequest, config);\n}\nexport { BasePatch, BaseTransaction, ClientError, ObservablePatch, ObservableSanityClient, ObservableTransaction, Patch, SanityClient, ServerError, Transaction, createClient, deprecatedCreateClient as default, requester };","map":{"version":3,"mappings":"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","names":["ClientError","Error","constructor","res","extractErrorProps","props","message","Object","ServerError","body","response","statusCode","responseBody","stringifyBody","details","error","description","httpErrorMessage","statusMessage","contentType","toLowerCase","isJson","indexOf","JSON","httpError","onResponse","printWarnings","warnings","Array","warn","Boolean","msg","defineHttpRequest","envMiddleware","request","getIt","jsonRequest","jsonResponse","progress","observable","implementation","options","requester","maxRedirects","httpRequest","defaultRequester","projectHeader","requestOptions","overrides","headers","config","token","Authorization","projectId","withCredentials","timeout","assign","proxy","json","getSelection","sel","id","params","query","selectionOpts","join","VALID_ASSET_TYPES","VALID_INSERT_LOCATIONS","name","test","type","op","val","doc","_id","validateDocumentId","validateInsert","at","items","signature","map","loc","valid","selector","isArray","dataset","tag","encodeQueryString","_ref","URLSearchParams","opts","searchParams","key","set","value","BasePatch","operations","selection","attrs","_assign","setIfMissing","diffMatchPatch","validateObject","unset","inc","dec","insert","append","prepend","splice","start","delAll","deleteCount","startIndex","delCount","Math","max","delRange","rangeSelector","ifRevisionId","rev","ifRevisionID","serialize","toJSON","reset","merge","_set","_ObservablePatch","client","__privateAdd","__privateSet","_client","clone","commit","__privateGet","returnFirst","returnDocuments","mutate","patch","ObservablePatch","_Patch","Patch","defaultMutateOptions","BaseTransaction","transactionId","trxId","create","validators.validateObject","createIfNotExists","validators.requireDocumentId","_add","createOrReplace","delete","documentId","validators.validateDocumentId","mut","push","_Transaction","patchOrDocumentId","patchOps","isPatch","isBuilder","Transaction","_ObservableTransaction","ObservableTransaction","excludeFalsey","param","defValue","getMutationQuery","dryRun","returnIds","visibility","autoGenerateArrayKeys","skipCrossDatasetReferenceValidation","isResponse","event","getBody","indexBy","docs","reduce","indexed","getQuerySizeLimit","_fetch","filterResponse","_dataRequest","pipe","mapResponse","_getDocument","uri","_requestObservable","filter","documents","_getDocuments","ids","_createIfNotExists","_create","_createOrReplace","_delete","mutations","_mutate","muts","endpoint","isMutation","isQuery","strQuery","useGet","length","stringQuery","reqOptions","method","canUseCdn","signal","results","document","mutation","useCdn","url","Observable","subscriber","subscribe","_withAbortSignal","path","validators.hasDataset","operation","baseUri","replace","_getUrl","cdnUrl","base","input","observer","abort","aborted","subscription","unsubscribe","isDomExceptionSupported","DOMException","_createAbortError","reason","_b","ObservableAssetsClient","_httpRequest","upload","assetType","_upload","AssetsClient","validators.validateAssetType","extract","meta","optionsFromFile","label","title","creditLine","filename","source","sourceId","sourceName","sourceUrl","assetEndpoint","file","window","File","preserveFilename","BASE_URL","generateHelpUrl","slug","once","fn","didCall","returnValue","createWarningPrinter","args","console","printCdnWarning","printBrowserTokenWarning","printNoApiVersionSpecifiedWarning","printNoDefaultExport","defaultCdnHost","defaultConfig","apiHost","apiVersion","useProjectHostname","LOCALHOSTS","isLocal","host","validateApiVersion","Date","apiDate","apiVersionValid","prevConfig","specifiedConfig","warnings.printNoApiVersionSpecifiedWarning","newConfig","projectBased","Promise","helpUrl","isBrowser","location","isLocalhost","hostname","ignoreBrowserTokenWarning","warnings.printBrowserTokenWarning","warnings.printCdnWarning","validate.projectId","validate.dataset","validate.requestTag","hostParts","protocol","cdnHost","obj","defaults","target","prop","MAX_URL_LENGTH","EventSource","possibleOptions","defaultOptions","includeResult","_listen","requestTagPrefix","pick","listenOpts","_getDataUrl","qs","listenFor","shouldEmitReconnect","esOptions","es","getEventSource","stopped","onError","emitReconnect","readyState","CLOSED","clearTimeout","reconnectTimer","open","onChannelError","err","cooerceError","onMessage","evt","parseEvent","next","onDisconnect","complete","removeEventListener","close","evs","addEventListener","stop","data","parse","extractErrorMessage","stringify","ObservableDatasetsClient","_modify","edit","list","DatasetsClient","_request","ObservableProjectsClient","getById","ProjectsClient","ObservableUsersClient","UsersClient","_ObservableSanityClient","assets","datasets","projects","users","_clientConfig","allowReconfigure","initConfig","withConfig","fetch","dataMethods._fetch","getDocument","dataMethods._getDocument","getDocuments","dataMethods._getDocuments","dataMethods._create","dataMethods._createIfNotExists","dataMethods._createOrReplace","dataMethods._delete","dataMethods._mutate","transaction","dataMethods._request","getUrl","dataMethods._getUrl","getDataUrl","dataMethods._getDataUrl","ObservableSanityClient","_SanityClient","lastValueFrom","dataRequest","dataMethods._dataRequest","SanityClient","createClient","deprecatedCreateClient"],"sources":["/Users/rgthardkor/node_modules/@sanity/client/src/http/browserMiddleware.ts","/Users/rgthardkor/node_modules/@sanity/client/src/http/errors.ts","/Users/rgthardkor/node_modules/@sanity/client/src/http/request.ts","/Users/rgthardkor/node_modules/@sanity/client/src/http/requestOptions.ts","/Users/rgthardkor/node_modules/@sanity/client/src/util/getSelection.ts","/Users/rgthardkor/node_modules/@sanity/client/src/validators.ts","/Users/rgthardkor/node_modules/@sanity/client/src/data/encodeQueryString.ts","/Users/rgthardkor/node_modules/@sanity/client/src/data/patch.ts","/Users/rgthardkor/node_modules/@sanity/client/src/data/transaction.ts","/Users/rgthardkor/node_modules/@sanity/client/src/data/dataMethods.ts","/Users/rgthardkor/node_modules/@sanity/client/src/assets/AssetsClient.ts","/Users/rgthardkor/node_modules/@sanity/client/src/generateHelpUrl.ts","/Users/rgthardkor/node_modules/@sanity/client/src/util/once.ts","/Users/rgthardkor/node_modules/@sanity/client/src/warnings.ts","/Users/rgthardkor/node_modules/@sanity/client/src/config.ts","/Users/rgthardkor/node_modules/@sanity/client/src/util/defaults.ts","/Users/rgthardkor/node_modules/@sanity/client/src/util/pick.ts","/Users/rgthardkor/node_modules/@sanity/client/src/data/listen.ts","/Users/rgthardkor/node_modules/@sanity/client/src/datasets/DatasetsClient.ts","/Users/rgthardkor/node_modules/@sanity/client/src/projects/ProjectsClient.ts","/Users/rgthardkor/node_modules/@sanity/client/src/users/UsersClient.ts","/Users/rgthardkor/node_modules/@sanity/client/src/SanityClient.ts","/Users/rgthardkor/node_modules/@sanity/client/src/index.browser.ts"],"sourcesContent":["export default []\n","import type {Any, ErrorProps} from '../types'\n\n/** @public */\nexport class ClientError extends Error {\n  response: ErrorProps['response']\n  statusCode: ErrorProps['statusCode'] = 400\n  responseBody: ErrorProps['responseBody']\n  details: ErrorProps['details']\n\n  constructor(res: Any) {\n    const props = extractErrorProps(res)\n    super(props.message)\n    Object.assign(this, props)\n  }\n}\n\n/** @public */\nexport class ServerError extends Error {\n  response: ErrorProps['response']\n  statusCode: ErrorProps['statusCode'] = 500\n  responseBody: ErrorProps['responseBody']\n  details: ErrorProps['details']\n\n  constructor(res: Any) {\n    const props = extractErrorProps(res)\n    super(props.message)\n    Object.assign(this, props)\n  }\n}\n\nfunction extractErrorProps(res: Any): ErrorProps {\n  const body = res.body\n  const props = {\n    response: res,\n    statusCode: res.statusCode,\n    responseBody: stringifyBody(body, res),\n    message: '',\n    details: undefined as Any,\n  }\n\n  // API/Boom style errors ({statusCode, error, message})\n  if (body.error && body.message) {\n    props.message = `${body.error} - ${body.message}`\n    return props\n  }\n\n  // Query/database errors ({error: {description, other, arb, props}})\n  if (body.error && body.error.description) {\n    props.message = body.error.description\n    props.details = body.error\n    return props\n  }\n\n  // Other, more arbitrary errors\n  props.message = body.error || body.message || httpErrorMessage(res)\n  return props\n}\n\nfunction httpErrorMessage(res: Any) {\n  const statusMessage = res.statusMessage ? ` ${res.statusMessage}` : ''\n  return `${res.method}-request to ${res.url} resulted in HTTP ${res.statusCode}${statusMessage}`\n}\n\nfunction stringifyBody(body: Any, res: Any) {\n  const contentType = (res.headers['content-type'] || '').toLowerCase()\n  const isJson = contentType.indexOf('application/json') !== -1\n  return isJson ? JSON.stringify(body, null, 2) : body\n}\n","import {getIt, type Middlewares} from 'get-it'\nimport {jsonRequest, jsonResponse, observable, progress} from 'get-it/middleware'\nimport {Observable} from 'rxjs'\n\nimport type {Any, HttpRequest, RequestOptions} from '../types'\nimport {ClientError, ServerError} from './errors'\n\nconst httpError = {\n  onResponse: (res: Any) => {\n    if (res.statusCode >= 500) {\n      throw new ServerError(res)\n    } else if (res.statusCode >= 400) {\n      throw new ClientError(res)\n    }\n\n    return res\n  },\n}\n\nconst printWarnings = {\n  onResponse: (res: Any) => {\n    const warn = res.headers['x-sanity-warning']\n    const warnings = Array.isArray(warn) ? warn : [warn]\n    warnings.filter(Boolean).forEach((msg) => console.warn(msg)) // eslint-disable-line no-console\n    return res\n  },\n}\n\n/** @internal */\nexport function defineHttpRequest(envMiddleware: Middlewares): HttpRequest {\n  const request = getIt([\n    ...envMiddleware,\n    printWarnings,\n    jsonRequest(),\n    jsonResponse(),\n    progress(),\n    httpError,\n    observable({implementation: Observable}),\n  ])\n\n  function httpRequest(options: RequestOptions, requester = request) {\n    return requester({maxRedirects: 0, ...options} as Any)\n  }\n\n  httpRequest.defaultRequester = request\n\n  return httpRequest\n}\n","import type {RequestOptions} from 'get-it'\n\nimport type {Any} from '../types'\n\nconst projectHeader = 'X-Sanity-Project-ID'\n\nexport function requestOptions(config: Any, overrides: Any = {}): Omit<RequestOptions, 'url'> {\n  const headers: Any = {}\n\n  const token = overrides.token || config.token\n  if (token) {\n    headers.Authorization = `Bearer ${token}`\n  }\n\n  if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {\n    headers[projectHeader] = config.projectId\n  }\n\n  const withCredentials = Boolean(\n    typeof overrides.withCredentials === 'undefined'\n      ? config.token || config.withCredentials\n      : overrides.withCredentials\n  )\n\n  const timeout = typeof overrides.timeout === 'undefined' ? config.timeout : overrides.timeout\n  return Object.assign({}, overrides, {\n    headers: Object.assign({}, headers, overrides.headers || {}),\n    timeout: typeof timeout === 'undefined' ? 5 * 60 * 1000 : timeout,\n    proxy: overrides.proxy || config.proxy,\n    json: true,\n    withCredentials,\n  })\n}\n","import type {MutationSelection} from '../types'\n\nexport function getSelection(sel: unknown): MutationSelection {\n  if (typeof sel === 'string' || Array.isArray(sel)) {\n    return {id: sel}\n  }\n\n  if (typeof sel === 'object' && sel !== null && 'query' in sel && typeof sel.query === 'string') {\n    return 'params' in sel && typeof sel.params === 'object' && sel.params !== null\n      ? {query: sel.query, params: sel.params}\n      : {query: sel.query}\n  }\n\n  const selectionOpts = [\n    '* Document ID (<docId>)',\n    '* Array of document IDs',\n    '* Object containing `query`',\n  ].join('\\n')\n\n  throw new Error(`Unknown selection - must be one of:\\n\\n${selectionOpts}`)\n}\n","import type {Any, InitializedClientConfig} from './types'\n\nconst VALID_ASSET_TYPES = ['image', 'file']\nconst VALID_INSERT_LOCATIONS = ['before', 'after', 'replace']\n\nexport const dataset = (name: string) => {\n  if (!/^(~[a-z0-9]{1}[-\\w]{0,63}|[a-z0-9]{1}[-\\w]{0,63})$/.test(name)) {\n    throw new Error(\n      'Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters'\n    )\n  }\n}\n\nexport const projectId = (id: string) => {\n  if (!/^[-a-z0-9]+$/i.test(id)) {\n    throw new Error('`projectId` can only contain only a-z, 0-9 and dashes')\n  }\n}\n\nexport const validateAssetType = (type: string) => {\n  if (VALID_ASSET_TYPES.indexOf(type) === -1) {\n    throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(', ')}`)\n  }\n}\n\nexport const validateObject = (op: string, val: Any) => {\n  if (val === null || typeof val !== 'object' || Array.isArray(val)) {\n    throw new Error(`${op}() takes an object of properties`)\n  }\n}\n\nexport const validateDocumentId = (op: string, id: string) => {\n  if (typeof id !== 'string' || !/^[a-z0-9_.-]+$/i.test(id)) {\n    throw new Error(`${op}(): \"${id}\" is not a valid document ID`)\n  }\n}\n\nexport const requireDocumentId = (op: string, doc: Record<string, Any>) => {\n  if (!doc._id) {\n    throw new Error(`${op}() requires that the document contains an ID (\"_id\" property)`)\n  }\n\n  validateDocumentId(op, doc._id)\n}\n\nexport const validateInsert = (at: string, selector: string, items: Any[]) => {\n  const signature = 'insert(at, selector, items)'\n  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {\n    const valid = VALID_INSERT_LOCATIONS.map((loc) => `\"${loc}\"`).join(', ')\n    throw new Error(`${signature} takes an \"at\"-argument which is one of: ${valid}`)\n  }\n\n  if (typeof selector !== 'string') {\n    throw new Error(`${signature} takes a \"selector\"-argument which must be a string`)\n  }\n\n  if (!Array.isArray(items)) {\n    throw new Error(`${signature} takes an \"items\"-argument which must be an array`)\n  }\n}\n\nexport const hasDataset = (config: InitializedClientConfig): string => {\n  if (!config.dataset) {\n    throw new Error('`dataset` must be provided to perform queries')\n  }\n\n  return config.dataset || ''\n}\n\nexport const requestTag = (tag: string) => {\n  if (typeof tag !== 'string' || !/^[a-z0-9._-]{1,75}$/i.test(tag)) {\n    throw new Error(\n      `Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.`\n    )\n  }\n\n  return tag\n}\n","import type {Any, QueryParams} from '../types'\n\nexport const encodeQueryString = ({\n  query,\n  params = {},\n  options = {},\n}: {\n  query: string\n  params?: QueryParams\n  options?: Any\n}) => {\n  const searchParams = new URLSearchParams()\n  // We generally want tag at the start of the query string\n  const {tag, ...opts} = options\n  if (tag) searchParams.set('tag', tag)\n  searchParams.set('query', query)\n\n  // Iterate params, the keys are prefixed with `$` and their values JSON stringified\n  for (const [key, value] of Object.entries(params)) {\n    searchParams.set(`$${key}`, JSON.stringify(value))\n  }\n  // Options are passed as-is\n  for (const [key, value] of Object.entries(opts)) {\n    // Skip falsy values\n    if (value) searchParams.set(key, `${value}`)\n  }\n\n  return `?${searchParams}`\n}\n","import {type Observable} from 'rxjs'\n\nimport type {ObservableSanityClient, SanityClient} from '../SanityClient'\nimport type {\n  AllDocumentIdsMutationOptions,\n  AllDocumentsMutationOptions,\n  Any,\n  AttributeSet,\n  BaseMutationOptions,\n  FirstDocumentIdMutationOptions,\n  FirstDocumentMutationOptions,\n  MultipleMutationResult,\n  PatchMutationOperation,\n  PatchOperations,\n  PatchSelection,\n  SanityDocument,\n  SingleMutationResult,\n} from '../types'\nimport {getSelection} from '../util/getSelection'\nimport {validateInsert, validateObject} from '../validators'\n\n/** @internal */\nexport class BasePatch {\n  protected selection: PatchSelection\n  protected operations: PatchOperations\n  constructor(selection: PatchSelection, operations: PatchOperations = {}) {\n    this.selection = selection\n    this.operations = operations\n  }\n\n  /**\n   * Sets the given attributes to the document. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  set(attrs: AttributeSet): this {\n    return this._assign('set', attrs)\n  }\n\n  /**\n   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  setIfMissing(attrs: AttributeSet): this {\n    return this._assign('setIfMissing', attrs)\n  }\n\n  /**\n   * Performs a \"diff-match-patch\" operation on the string attributes provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"dmp\"\\}\n   */\n  diffMatchPatch(attrs: AttributeSet): this {\n    validateObject('diffMatchPatch', attrs)\n    return this._assign('diffMatchPatch', attrs)\n  }\n\n  /**\n   * Unsets the attribute paths provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attribute paths to unset.\n   */\n  unset(attrs: string[]): this {\n    if (!Array.isArray(attrs)) {\n      throw new Error('unset(attrs) takes an array of attributes to unset, non-array given')\n    }\n\n    this.operations = Object.assign({}, this.operations, {unset: attrs})\n    return this\n  }\n\n  /**\n   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.\n   */\n  inc(attrs: {[key: string]: number}): this {\n    return this._assign('inc', attrs)\n  }\n\n  /**\n   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.\n   */\n  dec(attrs: {[key: string]: number}): this {\n    return this._assign('dec', attrs)\n  }\n\n  /**\n   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.\n   *\n   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path\n   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key==\"abc123\"]`\n   * @param items - Array of items to insert/replace\n   */\n  insert(at: 'before' | 'after' | 'replace', selector: string, items: Any[]): this {\n    validateInsert(at, selector, items)\n    return this._assign('insert', {[at]: selector, items})\n  }\n\n  /**\n   * Append the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to append to the array\n   */\n  append(selector: string, items: Any[]): this {\n    return this.insert('after', `${selector}[-1]`, items)\n  }\n\n  /**\n   * Prepend the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to prepend to the array\n   */\n  prepend(selector: string, items: Any[]): this {\n    return this.insert('before', `${selector}[0]`, items)\n  }\n\n  /**\n   * Change the contents of an array by removing existing elements and/or adding new elements.\n   *\n   * @param selector - Attribute or JSONPath expression for array\n   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x\n   * @param deleteCount - An integer indicating the number of old array elements to remove.\n   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.\n   */\n  splice(selector: string, start: number, deleteCount?: number, items?: Any[]): this {\n    // Negative indexes doesn't mean the same in Sanity as they do in JS;\n    // -1 means \"actually at the end of the array\", which allows inserting\n    // at the end of the array without knowing its length. We therefore have\n    // to substract negative indexes by one to match JS. If you want Sanity-\n    // behaviour, just use `insert('replace', selector, items)` directly\n    const delAll = typeof deleteCount === 'undefined' || deleteCount === -1\n    const startIndex = start < 0 ? start - 1 : start\n    const delCount = delAll ? -1 : Math.max(0, start + deleteCount)\n    const delRange = startIndex < 0 && delCount >= 0 ? '' : delCount\n    const rangeSelector = `${selector}[${startIndex}:${delRange}]`\n    return this.insert('replace', rangeSelector, items || [])\n  }\n\n  /**\n   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value\n   *\n   * @param rev - Revision to lock the patch to\n   */\n  ifRevisionId(rev: string): this {\n    this.operations.ifRevisionID = rev\n    return this\n  }\n\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  serialize(): PatchMutationOperation {\n    return {...getSelection(this.selection), ...this.operations}\n  }\n\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  toJSON(): PatchMutationOperation {\n    return this.serialize()\n  }\n\n  /**\n   * Clears the patch of all operations\n   */\n  reset(): this {\n    this.operations = {}\n    return this\n  }\n\n  protected _assign(op: keyof PatchOperations, props: Any, merge = true): this {\n    validateObject(op, props)\n    this.operations = Object.assign({}, this.operations, {\n      [op]: Object.assign({}, (merge && this.operations[op]) || {}, props),\n    })\n    return this\n  }\n\n  protected _set(op: keyof PatchOperations, props: Any): this {\n    return this._assign(op, props, false)\n  }\n}\n\n/** @public */\nexport class ObservablePatch extends BasePatch {\n  #client?: ObservableSanityClient\n\n  constructor(\n    selection: PatchSelection,\n    operations?: PatchOperations,\n    client?: ObservableSanityClient\n  ) {\n    super(selection, operations)\n    this.#client = client\n  }\n\n  /**\n   * Clones the patch\n   */\n  clone(): ObservablePatch {\n    return new ObservablePatch(this.selection, {...this.operations}, this.#client)\n  }\n\n  /**\n   * Commit the patch, returning an observable that produces the first patched document\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options: FirstDocumentMutationOptions\n  ): Observable<SanityDocument<R>>\n  /**\n   * Commit the patch, returning an observable that produces an array of the mutated documents\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options: AllDocumentsMutationOptions\n  ): Observable<SanityDocument<R>[]>\n  /**\n   * Commit the patch, returning an observable that produces a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options: FirstDocumentIdMutationOptions): Observable<SingleMutationResult>\n  /**\n   * Commit the patch, returning an observable that produces a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options: AllDocumentIdsMutationOptions): Observable<MultipleMutationResult>\n  /**\n   * Commit the patch, returning an observable that produces the first patched document\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options?: BaseMutationOptions\n  ): Observable<SanityDocument<R>>\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options?:\n      | FirstDocumentMutationOptions\n      | AllDocumentsMutationOptions\n      | FirstDocumentIdMutationOptions\n      | AllDocumentIdsMutationOptions\n      | BaseMutationOptions\n  ): Observable<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    if (!this.#client) {\n      throw new Error(\n        'No `client` passed to patch, either provide one or pass the ' +\n          'patch to a clients `mutate()` method'\n      )\n    }\n\n    const returnFirst = typeof this.selection === 'string'\n    const opts = Object.assign({returnFirst, returnDocuments: true}, options)\n    return this.#client.mutate<R>({patch: this.serialize()} as Any, opts)\n  }\n}\n\n/** @public */\nexport class Patch extends BasePatch {\n  #client?: SanityClient\n  constructor(selection: PatchSelection, operations?: PatchOperations, client?: SanityClient) {\n    super(selection, operations)\n    this.#client = client\n  }\n\n  /**\n   * Clones the patch\n   */\n  clone(): Patch {\n    return new Patch(this.selection, {...this.operations}, this.#client)\n  }\n\n  /**\n   * Commit the patch, returning a promise that resolves to the first patched document\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options: FirstDocumentMutationOptions\n  ): Promise<SanityDocument<R>>\n  /**\n   * Commit the patch, returning a promise that resolves to an array of the mutated documents\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options: AllDocumentsMutationOptions\n  ): Promise<SanityDocument<R>[]>\n  /**\n   * Commit the patch, returning a promise that resolves to a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options: FirstDocumentIdMutationOptions): Promise<SingleMutationResult>\n  /**\n   * Commit the patch, returning a promise that resolves to a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options: AllDocumentIdsMutationOptions): Promise<MultipleMutationResult>\n  /**\n   * Commit the patch, returning a promise that resolves to the first patched document\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options?: BaseMutationOptions\n  ): Promise<SanityDocument<R>>\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options?:\n      | FirstDocumentMutationOptions\n      | AllDocumentsMutationOptions\n      | FirstDocumentIdMutationOptions\n      | AllDocumentIdsMutationOptions\n      | BaseMutationOptions\n  ): Promise<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    if (!this.#client) {\n      throw new Error(\n        'No `client` passed to patch, either provide one or pass the ' +\n          'patch to a clients `mutate()` method'\n      )\n    }\n\n    const returnFirst = typeof this.selection === 'string'\n    const opts = Object.assign({returnFirst, returnDocuments: true}, options)\n    return this.#client.mutate<R>({patch: this.serialize()} as Any, opts)\n  }\n}\n","import type {Observable} from 'rxjs'\n\nimport type {ObservableSanityClient, SanityClient} from '../SanityClient'\nimport type {\n  Any,\n  BaseMutationOptions,\n  IdentifiedSanityDocumentStub,\n  MultipleMutationResult,\n  Mutation,\n  PatchOperations,\n  SanityDocument,\n  SanityDocumentStub,\n  SingleMutationResult,\n  TransactionAllDocumentIdsMutationOptions,\n  TransactionAllDocumentsMutationOptions,\n  TransactionFirstDocumentIdMutationOptions,\n  TransactionFirstDocumentMutationOptions,\n} from '../types'\nimport * as validators from '../validators'\nimport {ObservablePatch, Patch} from './patch'\n\n/** @public */\nexport type PatchBuilder = (patch: Patch) => Patch\n/** @public */\nexport type ObservablePatchBuilder = (patch: ObservablePatch) => ObservablePatch\n\nconst defaultMutateOptions = {returnDocuments: false}\n\n/** @internal */\nexport class BaseTransaction {\n  protected operations: Mutation[]\n  protected trxId?: string\n  constructor(operations: Mutation[] = [], transactionId?: string) {\n    this.operations = operations\n    this.trxId = transactionId\n  }\n  /**\n   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create. Requires a `_type` property.\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(doc: SanityDocumentStub<R>): this {\n    validators.validateObject('create', doc)\n    return this._add({create: doc})\n  }\n\n  /**\n   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    doc: IdentifiedSanityDocumentStub<R>\n  ): this {\n    const op = 'createIfNotExists'\n    validators.validateObject(op, doc)\n    validators.requireDocumentId(op, doc)\n    return this._add({[op]: doc})\n  }\n\n  /**\n   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    doc: IdentifiedSanityDocumentStub<R>\n  ): this {\n    const op = 'createOrReplace'\n    validators.validateObject(op, doc)\n    validators.requireDocumentId(op, doc)\n    return this._add({[op]: doc})\n  }\n\n  /**\n   * Deletes the document with the given document ID\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to delete\n   */\n  delete(documentId: string): this {\n    validators.validateDocumentId('delete', documentId)\n    return this._add({delete: {id: documentId}})\n  }\n\n  /**\n   * Gets the current transaction ID, if any\n   */\n  transactionId(): string | undefined\n  /**\n   * Set the ID of this transaction.\n   *\n   * @param id - Transaction ID\n   */\n  transactionId(id: string): this\n  transactionId(id?: string): this | string | undefined {\n    if (!id) {\n      return this.trxId\n    }\n\n    this.trxId = id\n    return this\n  }\n\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  serialize(): Mutation[] {\n    return [...this.operations]\n  }\n\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  toJSON(): Mutation[] {\n    return this.serialize()\n  }\n\n  /**\n   * Clears the transaction of all operations\n   */\n  reset(): this {\n    this.operations = []\n    return this\n  }\n\n  protected _add(mut: Mutation): this {\n    this.operations.push(mut)\n    return this\n  }\n}\n\n/** @public */\nexport class Transaction extends BaseTransaction {\n  #client?: SanityClient\n  constructor(operations?: Mutation[], client?: SanityClient, transactionId?: string) {\n    super(operations, transactionId)\n    this.#client = client\n  }\n\n  /**\n   * Clones the transaction\n   */\n  clone(): Transaction {\n    return new Transaction([...this.operations], this.#client, this.trxId)\n  }\n\n  /**\n   * Commit the transaction, returning a promise that resolves to the first mutated document\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any>>(\n    options: TransactionFirstDocumentMutationOptions\n  ): Promise<SanityDocument<R>>\n  /**\n   * Commit the transaction, returning a promise that resolves to an array of the mutated documents\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any>>(\n    options: TransactionAllDocumentsMutationOptions\n  ): Promise<SanityDocument<R>[]>\n  /**\n   * Commit the transaction, returning a promise that resolves to a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options: TransactionFirstDocumentIdMutationOptions): Promise<SingleMutationResult>\n  /**\n   * Commit the transaction, returning a promise that resolves to a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options: TransactionAllDocumentIdsMutationOptions): Promise<MultipleMutationResult>\n  /**\n   * Commit the transaction, returning a promise that resolves to a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options?: BaseMutationOptions): Promise<MultipleMutationResult>\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options?:\n      | TransactionFirstDocumentMutationOptions\n      | TransactionAllDocumentsMutationOptions\n      | TransactionFirstDocumentIdMutationOptions\n      | TransactionAllDocumentIdsMutationOptions\n      | BaseMutationOptions\n  ): Promise<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    if (!this.#client) {\n      throw new Error(\n        'No `client` passed to transaction, either provide one or pass the ' +\n          'transaction to a clients `mutate()` method'\n      )\n    }\n\n    return this.#client.mutate<R>(\n      this.serialize() as Any,\n      Object.assign({transactionId: this.trxId}, defaultMutateOptions, options || {})\n    )\n  }\n\n  /**\n   * Performs a patch on the given document ID. Can either be a builder function or an object of patch operations.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to perform the patch operation on\n   * @param patchOps - Operations to perform, or a builder function\n   */\n  patch(documentId: string, patchOps?: PatchBuilder | PatchOperations): this\n  /**\n   * Adds the given patch instance to the transaction.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param patch - Patch to execute\n   */\n  patch(patch: Patch): this\n  patch(patchOrDocumentId: Patch | string, patchOps?: PatchBuilder | PatchOperations): this {\n    const isBuilder = typeof patchOps === 'function'\n    const isPatch = typeof patchOrDocumentId !== 'string' && patchOrDocumentId instanceof Patch\n\n    // transaction.patch(client.patch('documentId').inc({visits: 1}))\n    if (isPatch) {\n      return this._add({patch: patchOrDocumentId.serialize()})\n    }\n\n    // patch => patch.inc({visits: 1}).set({foo: 'bar'})\n    if (isBuilder) {\n      const patch = patchOps(new Patch(patchOrDocumentId, {}, this.#client))\n      if (!(patch instanceof Patch)) {\n        throw new Error('function passed to `patch()` must return the patch')\n      }\n\n      return this._add({patch: patch.serialize()})\n    }\n\n    return this._add({patch: {id: patchOrDocumentId, ...patchOps}})\n  }\n}\n\n/** @public */\nexport class ObservableTransaction extends BaseTransaction {\n  #client?: ObservableSanityClient\n  constructor(operations?: Mutation[], client?: ObservableSanityClient, transactionId?: string) {\n    super(operations, transactionId)\n    this.#client = client\n  }\n\n  /**\n   * Clones the transaction\n   */\n  clone(): ObservableTransaction {\n    return new ObservableTransaction([...this.operations], this.#client, this.trxId)\n  }\n\n  /**\n   * Commit the transaction, returning an observable that produces the first mutated document\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any>>(\n    options: TransactionFirstDocumentMutationOptions\n  ): Observable<SanityDocument<R>>\n  /**\n   * Commit the transaction, returning an observable that produces an array of the mutated documents\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit<R extends Record<string, Any>>(\n    options: TransactionAllDocumentsMutationOptions\n  ): Observable<SanityDocument<R>[]>\n  /**\n   * Commit the transaction, returning an observable that produces a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options: TransactionFirstDocumentIdMutationOptions): Observable<SingleMutationResult>\n  /**\n   * Commit the transaction, returning an observable that produces a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options: TransactionAllDocumentIdsMutationOptions): Observable<MultipleMutationResult>\n  /**\n   * Commit the transaction, returning an observable that produces a mutation result object\n   *\n   * @param options - Options for the mutation operation\n   */\n  commit(options?: BaseMutationOptions): Observable<MultipleMutationResult>\n  commit<R extends Record<string, Any> = Record<string, Any>>(\n    options?:\n      | TransactionFirstDocumentMutationOptions\n      | TransactionAllDocumentsMutationOptions\n      | TransactionFirstDocumentIdMutationOptions\n      | TransactionAllDocumentIdsMutationOptions\n      | BaseMutationOptions\n  ): Observable<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    if (!this.#client) {\n      throw new Error(\n        'No `client` passed to transaction, either provide one or pass the ' +\n          'transaction to a clients `mutate()` method'\n      )\n    }\n\n    return this.#client.mutate<R>(\n      this.serialize() as Any,\n      Object.assign({transactionId: this.trxId}, defaultMutateOptions, options || {})\n    )\n  }\n\n  /**\n   * Performs a patch on the given document ID. Can either be a builder function or an object of patch operations.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to perform the patch operation on\n   * @param patchOps - Operations to perform, or a builder function\n   */\n  patch(documentId: string, patchOps?: ObservablePatchBuilder | PatchOperations): this\n  /**\n   * Adds the given patch instance to the transaction.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param patch - ObservablePatch to execute\n   */\n  patch(patch: ObservablePatch): this\n  patch(\n    patchOrDocumentId: ObservablePatch | string,\n    patchOps?: ObservablePatchBuilder | PatchOperations\n  ): this {\n    const isBuilder = typeof patchOps === 'function'\n    const isPatch =\n      typeof patchOrDocumentId !== 'string' && patchOrDocumentId instanceof ObservablePatch\n\n    // transaction.patch(client.patch('documentId').inc({visits: 1}))\n    if (isPatch) {\n      return this._add({patch: patchOrDocumentId.serialize()})\n    }\n\n    // patch => patch.inc({visits: 1}).set({foo: 'bar'})\n    if (isBuilder) {\n      const patch = patchOps(new ObservablePatch(patchOrDocumentId, {}, this.#client))\n      if (!(patch instanceof ObservablePatch)) {\n        throw new Error('function passed to `patch()` must return the patch')\n      }\n\n      return this._add({patch: patch.serialize()})\n    }\n\n    return this._add({patch: {id: patchOrDocumentId, ...patchOps}})\n  }\n}\n","import {type MonoTypeOperatorFunction, Observable} from 'rxjs'\nimport {filter, map} from 'rxjs/operators'\n\nimport {requestOptions} from '../http/requestOptions'\nimport type {ObservableSanityClient, SanityClient} from '../SanityClient'\nimport type {\n  AllDocumentIdsMutationOptions,\n  AllDocumentsMutationOptions,\n  Any,\n  BaseMutationOptions,\n  FilteredResponseQueryOptions,\n  FirstDocumentIdMutationOptions,\n  FirstDocumentMutationOptions,\n  HttpRequest,\n  HttpRequestEvent,\n  IdentifiedSanityDocumentStub,\n  MultipleMutationResult,\n  Mutation,\n  MutationSelection,\n  QueryParams,\n  RawQueryResponse,\n  RequestObservableOptions,\n  RequestOptions,\n  SanityDocument,\n  SingleMutationResult,\n  UnfilteredResponseQueryOptions,\n} from '../types'\nimport {getSelection} from '../util/getSelection'\nimport * as validate from '../validators'\nimport * as validators from '../validators'\nimport {encodeQueryString} from './encodeQueryString'\nimport {ObservablePatch, Patch} from './patch'\nimport {ObservableTransaction, Transaction} from './transaction'\n\nconst excludeFalsey = (param: Any, defValue: Any) => {\n  const value = typeof param === 'undefined' ? defValue : param\n  return param === false ? undefined : value\n}\n\nconst getMutationQuery = (options: BaseMutationOptions = {}) => {\n  return {\n    dryRun: options.dryRun,\n    returnIds: true,\n    returnDocuments: excludeFalsey(options.returnDocuments, true),\n    visibility: options.visibility || 'sync',\n    autoGenerateArrayKeys: options.autoGenerateArrayKeys,\n    skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation,\n  }\n}\n\nconst isResponse = (event: Any) => event.type === 'response'\nconst getBody = (event: Any) => event.body\n\nconst indexBy = (docs: Any[], attr: Any) =>\n  docs.reduce((indexed, doc) => {\n    indexed[attr(doc)] = doc\n    return indexed\n  }, Object.create(null))\n\nconst getQuerySizeLimit = 11264\n\n/** @internal */\nexport function _fetch<R, Q extends QueryParams>(\n  client: ObservableSanityClient | SanityClient,\n  httpRequest: HttpRequest,\n  query: string,\n  params?: Q,\n  options: FilteredResponseQueryOptions | UnfilteredResponseQueryOptions = {}\n): Observable<RawQueryResponse<R> | R> {\n  const mapResponse =\n    options.filterResponse === false ? (res: Any) => res : (res: Any) => res.result\n\n  return _dataRequest(client, httpRequest, 'query', {query, params}, options).pipe(map(mapResponse))\n}\n\n/** @internal */\nexport function _getDocument<R extends Record<string, Any>>(\n  client: ObservableSanityClient | SanityClient,\n  httpRequest: HttpRequest,\n  id: string,\n  opts: {tag?: string} = {}\n): Observable<SanityDocument<R> | undefined> {\n  const options = {uri: _getDataUrl(client, 'doc', id), json: true, tag: opts.tag}\n  return _requestObservable<SanityDocument<R> | undefined>(client, httpRequest, options).pipe(\n    filter(isResponse),\n    map((event) => event.body.documents && event.body.documents[0])\n  )\n}\n\n/** @internal */\nexport function _getDocuments<R extends Record<string, Any>>(\n  client: ObservableSanityClient | SanityClient,\n  httpRequest: HttpRequest,\n  ids: string[],\n  opts: {tag?: string} = {}\n): Observable<(SanityDocument<R> | null)[]> {\n  const options = {uri: _getDataUrl(client, 'doc', ids.join(',')), json: true, tag: opts.tag}\n  return _requestObservable<(SanityDocument<R> | null)[]>(client, httpRequest, options).pipe(\n    filter(isResponse),\n    map((event: Any) => {\n      const indexed = indexBy(event.body.documents || [], (doc: Any) => doc._id)\n      return ids.map((id) => indexed[id] || null)\n    })\n  )\n}\n\n/** @internal */\nexport function _createIfNotExists<R extends Record<string, Any>>(\n  client: ObservableSanityClient | SanityClient,\n  httpRequest: HttpRequest,\n  doc: IdentifiedSanityDocumentStub<R>,\n  options?:\n    | AllDocumentIdsMutationOptions\n    | AllDocumentsMutationOptions\n    | BaseMutationOptions\n    | FirstDocumentIdMutationOptions\n    | FirstDocumentMutationOptions\n): Observable<\n  SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n> {\n  validators.requireDocumentId('createIfNotExists', doc)\n  return _create<R>(client, httpRequest, doc, 'createIfNotExists', options)\n}\n\n/** @internal */\nexport function _createOrReplace<R extends Record<string, Any>>(\n  client: ObservableSanityClient | SanityClient,\n  httpRequest: HttpRequest,\n  doc: IdentifiedSanityDocumentStub<R>,\n  options?:\n    | AllDocumentIdsMutationOptions\n    | AllDocumentsMutationOptions\n    | BaseMutationOptions\n    | FirstDocumentIdMutationOptions\n    | FirstDocumentMutationOptions\n): Observable<\n  SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n> {\n  validators.requireDocumentId('createOrReplace', doc)\n  return _create<R>(client, httpRequest, doc, 'createOrReplace', options)\n}\n\n/** @internal */\nexport function _delete<R extends Record<string, Any>>(\n  client: ObservableSanityClient | SanityClient,\n  httpRequest: HttpRequest,\n  selection: string | MutationSelection,\n  options?:\n    | AllDocumentIdsMutationOptions\n    | AllDocumentsMutationOptions\n    | BaseMutationOptions\n    | FirstDocumentIdMutationOptions\n    | FirstDocumentMutationOptions\n): Observable<\n  SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n> {\n  return _dataRequest(\n    client,\n    httpRequest,\n    'mutate',\n    {mutations: [{delete: getSelection(selection)}]},\n    options\n  )\n}\n\n/** @internal */\nexport function _mutate<R extends Record<string, Any>>(\n  client: SanityClient | ObservableSanityClient,\n  httpRequest: HttpRequest,\n  mutations: Mutation<R>[] | Patch | ObservablePatch | Transaction | ObservableTransaction,\n  options?:\n    | AllDocumentIdsMutationOptions\n    | AllDocumentsMutationOptions\n    | BaseMutationOptions\n    | FirstDocumentIdMutationOptions\n    | FirstDocumentMutationOptions\n): Observable<\n  SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n> {\n  const mut =\n    mutations instanceof Patch ||\n    mutations instanceof ObservablePatch ||\n    mutations instanceof Transaction ||\n    mutations instanceof ObservableTransaction\n      ? mutations.serialize()\n      : mutations\n\n  const muts = Array.isArray(mut) ? mut : [mut]\n  const transactionId = options && (options as Any).transactionId\n  return _dataRequest(client, httpRequest, 'mutate', {mutations: muts, transactionId}, options)\n}\n\n/**\n * @internal\n */\nexport function _dataRequest(\n  client: SanityClient | ObservableSanityClient,\n  httpRequest: HttpRequest,\n  endpoint: string,\n  body: Any,\n  options: Any = {}\n): Any {\n  const isMutation = endpoint === 'mutate'\n  const isQuery = endpoint === 'query'\n\n  // Check if the query string is within a configured threshold,\n  // in which case we can use GET. Otherwise, use POST.\n  const strQuery = isMutation ? '' : encodeQueryString(body)\n  const useGet = !isMutation && strQuery.length < getQuerySizeLimit\n  const stringQuery = useGet ? strQuery : ''\n  const returnFirst = options.returnFirst\n  const {timeout, token, tag, headers} = options\n\n  const uri = _getDataUrl(client, endpoint, stringQuery)\n\n  const reqOptions = {\n    method: useGet ? 'GET' : 'POST',\n    uri: uri,\n    json: true,\n    body: useGet ? undefined : body,\n    query: isMutation && getMutationQuery(options),\n    timeout,\n    headers,\n    token,\n    tag,\n    canUseCdn: isQuery,\n    signal: options.signal,\n  }\n\n  return _requestObservable(client, httpRequest, reqOptions).pipe(\n    filter(isResponse),\n    map(getBody),\n    map((res) => {\n      if (!isMutation) {\n        return res\n      }\n\n      // Should we return documents?\n      const results = res.results || []\n      if (options.returnDocuments) {\n        return returnFirst\n          ? results[0] && results[0].document\n          : results.map((mut: Any) => mut.document)\n      }\n\n      // Return a reduced subset\n      const key = returnFirst ? 'documentId' : 'documentIds'\n      const ids = returnFirst ? results[0] && results[0].id : results.map((mut: Any) => mut.id)\n      return {\n        transactionId: res.transactionId,\n        results: results,\n        [key]: ids,\n      }\n    })\n  )\n}\n\n/**\n * @internal\n */\nexport function _create<R extends Record<string, Any>>(\n  client: SanityClient | ObservableSanityClient,\n  httpRequest: HttpRequest,\n  doc: Any,\n  op: Any,\n  options: Any = {}\n): Observable<\n  SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n> {\n  const mutation = {[op]: doc}\n  const opts = Object.assign({returnFirst: true, returnDocuments: true}, options)\n  return _dataRequest(client, httpRequest, 'mutate', {mutations: [mutation]}, opts)\n}\n\n/**\n * @internal\n */\nexport function _requestObservable<R>(\n  client: SanityClient | ObservableSanityClient,\n  httpRequest: HttpRequest,\n  options: RequestObservableOptions\n): Observable<HttpRequestEvent<R>> {\n  const uri = options.url || (options.uri as string)\n  const config = client.config()\n\n  // If the `canUseCdn`-option is not set we detect it automatically based on the method + URL.\n  // Only the /data endpoint is currently available through API-CDN.\n  const canUseCdn =\n    typeof options.canUseCdn === 'undefined'\n      ? ['GET', 'HEAD'].indexOf(options.method || 'GET') >= 0 && uri.indexOf('/data/') === 0\n      : options.canUseCdn\n\n  const useCdn = config.useCdn && canUseCdn\n\n  const tag =\n    options.tag && config.requestTagPrefix\n      ? [config.requestTagPrefix, options.tag].join('.')\n      : options.tag || config.requestTagPrefix\n\n  if (tag) {\n    options.query = {tag: validate.requestTag(tag), ...options.query}\n  }\n\n  const reqOptions = requestOptions(\n    config,\n    Object.assign({}, options, {\n      url: _getUrl(client, uri, useCdn),\n    })\n  ) as RequestOptions\n\n  const request = new Observable<HttpRequestEvent<R>>((subscriber) =>\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the typings thinks it's optional because it's not required to specify it when calling createClient, but it's always defined in practice since SanityClient provides a default\n    httpRequest(reqOptions, config.requester!).subscribe(subscriber)\n  )\n\n  return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request\n}\n\n/**\n * @internal\n */\nexport function _request<R>(\n  client: SanityClient | ObservableSanityClient,\n  httpRequest: HttpRequest,\n  options: Any\n): Observable<R> {\n  const observable = _requestObservable<R>(client, httpRequest, options).pipe(\n    filter((event: Any) => event.type === 'response'),\n    map((event: Any) => event.body)\n  )\n\n  return observable\n}\n\n/**\n * @internal\n */\nexport function _getDataUrl(\n  client: SanityClient | ObservableSanityClient,\n  operation: string,\n  path?: string\n): string {\n  const config = client.config()\n  const catalog = validators.hasDataset(config)\n  const baseUri = `/${operation}/${catalog}`\n  const uri = path ? `${baseUri}/${path}` : baseUri\n  return `/data${uri}`.replace(/\\/($|\\?)/, '$1')\n}\n\n/**\n * @internal\n */\nexport function _getUrl(\n  client: SanityClient | ObservableSanityClient,\n  uri: string,\n  canUseCdn = false\n): string {\n  const {url, cdnUrl} = client.config()\n  const base = canUseCdn ? cdnUrl : url\n  return `${base}/${uri.replace(/^\\//, '')}`\n}\n\n/**\n * @internal\n */\nfunction _withAbortSignal<T>(signal: AbortSignal): MonoTypeOperatorFunction<T> {\n  return (input) => {\n    return new Observable((observer) => {\n      const abort = () => observer.error(_createAbortError(signal))\n\n      if (signal && signal.aborted) {\n        abort()\n        return\n      }\n      const subscription = input.subscribe(observer)\n      signal.addEventListener('abort', abort)\n      return () => {\n        signal.removeEventListener('abort', abort)\n        subscription.unsubscribe()\n      }\n    })\n  }\n}\n// DOMException is supported on most modern browsers and Node.js 18+.\n// @see https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility\nconst isDomExceptionSupported = Boolean(globalThis.DOMException)\n\n/**\n * @internal\n * @param signal\n * Original source copied from https://github.com/sindresorhus/ky/blob/740732c78aad97e9aec199e9871bdbf0ae29b805/source/errors/DOMException.ts\n * TODO: When targeting Node.js 18, use `signal.throwIfAborted()` (https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted)\n */\nfunction _createAbortError(signal?: AbortSignal) {\n  /*\n  NOTE: Use DomException with AbortError name as specified in MDN docs (https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort)\n  > When abort() is called, the fetch() promise rejects with an Error of type DOMException, with name AbortError.\n  */\n  if (isDomExceptionSupported) {\n    return new DOMException(signal?.reason ?? 'The operation was aborted.', 'AbortError')\n  }\n\n  // DOMException not supported. Fall back to use of error and override name.\n  const error = new Error(signal?.reason ?? 'The operation was aborted.')\n  error.name = 'AbortError'\n\n  return error\n}\n","import {lastValueFrom, type Observable} from 'rxjs'\nimport {filter, map} from 'rxjs/operators'\n\nimport {_requestObservable} from '../data/dataMethods'\nimport type {ObservableSanityClient, SanityClient} from '../SanityClient'\nimport type {\n  Any,\n  HttpRequest,\n  HttpRequestEvent,\n  ResponseEvent,\n  SanityAssetDocument,\n  SanityImageAssetDocument,\n  UploadClientConfig,\n} from '../types'\nimport * as validators from '../validators'\n\n/** @internal */\nexport class ObservableAssetsClient {\n  #client: ObservableSanityClient\n  #httpRequest: HttpRequest\n  constructor(client: ObservableSanityClient, httpRequest: HttpRequest) {\n    this.#client = client\n    this.#httpRequest = httpRequest\n  }\n\n  /**\n   * Uploads a file asset to the configured dataset\n   *\n   * @param assetType - Asset type (file)\n   * @param body - Asset content - can be a browser File instance, a Blob, a Node.js Buffer instance or a Node.js ReadableStream.\n   * @param options - Options to use for the upload\n   */\n  upload(\n    assetType: 'file',\n    body: File | Blob | Buffer | NodeJS.ReadableStream,\n    options?: UploadClientConfig\n  ): Observable<HttpRequestEvent<{document: SanityAssetDocument}>>\n\n  /**\n   * Uploads an image asset to the configured dataset\n   *\n   * @param assetType - Asset type (image)\n   * @param body - Asset content - can be a browser File instance, a Blob, a Node.js Buffer instance or a Node.js ReadableStream.\n   * @param options - Options to use for the upload\n   */\n  upload(\n    assetType: 'image',\n    body: File | Blob | Buffer | NodeJS.ReadableStream,\n    options?: UploadClientConfig\n  ): Observable<HttpRequestEvent<{document: SanityImageAssetDocument}>>\n  /**\n   * Uploads a file or an image asset to the configured dataset\n   *\n   * @param assetType - Asset type (file/image)\n   * @param body - Asset content - can be a browser File instance, a Blob, a Node.js Buffer instance or a Node.js ReadableStream.\n   * @param options - Options to use for the upload\n   */\n  upload(\n    assetType: 'file' | 'image',\n    body: File | Blob | Buffer | NodeJS.ReadableStream,\n    options?: UploadClientConfig\n  ): Observable<HttpRequestEvent<{document: SanityAssetDocument | SanityImageAssetDocument}>>\n  upload(\n    assetType: 'file' | 'image',\n    body: File | Blob | Buffer | NodeJS.ReadableStream,\n    options?: UploadClientConfig\n  ): Observable<HttpRequestEvent<{document: SanityAssetDocument | SanityImageAssetDocument}>> {\n    return _upload(this.#client, this.#httpRequest, assetType, body, options)\n  }\n}\n\n/** @internal */\nexport class AssetsClient {\n  #client: SanityClient\n  #httpRequest: HttpRequest\n  constructor(client: SanityClient, httpRequest: HttpRequest) {\n    this.#client = client\n    this.#httpRequest = httpRequest\n  }\n\n  /**\n   * Uploads a file asset to the configured dataset\n   *\n   * @param assetType - Asset type (file)\n   * @param body - Asset content - can be a browser File instance, a Blob, a Node.js Buffer instance or a Node.js ReadableStream.\n   * @param options - Options to use for the upload\n   */\n  upload(\n    assetType: 'file',\n    body: File | Blob | Buffer | NodeJS.ReadableStream,\n    options?: UploadClientConfig\n  ): Promise<SanityAssetDocument>\n  /**\n   * Uploads an image asset to the configured dataset\n   *\n   * @param assetType - Asset type (image)\n   * @param body - Asset content - can be a browser File instance, a Blob, a Node.js Buffer instance or a Node.js ReadableStream.\n   * @param options - Options to use for the upload\n   */\n  upload(\n    assetType: 'image',\n    body: File | Blob | Buffer | NodeJS.ReadableStream,\n    options?: UploadClientConfig\n  ): Promise<SanityImageAssetDocument>\n  /**\n   * Uploads a file or an image asset to the configured dataset\n   *\n   * @param assetType - Asset type (file/image)\n   * @param body - Asset content - can be a browser File instance, a Blob, a Node.js Buffer instance or a Node.js ReadableStream.\n   * @param options - Options to use for the upload\n   */\n  upload(\n    assetType: 'file' | 'image',\n    body: File | Blob | Buffer | NodeJS.ReadableStream,\n    options?: UploadClientConfig\n  ): Promise<SanityAssetDocument | SanityImageAssetDocument>\n  upload(\n    assetType: 'file' | 'image',\n    body: File | Blob | Buffer | NodeJS.ReadableStream,\n    options?: UploadClientConfig\n  ): Promise<SanityAssetDocument | SanityImageAssetDocument> {\n    const observable = _upload(this.#client, this.#httpRequest, assetType, body, options)\n    return lastValueFrom(\n      observable.pipe(\n        filter((event: Any) => event.type === 'response'),\n        map(\n          (event) =>\n            (event as ResponseEvent<{document: SanityAssetDocument | SanityImageAssetDocument}>)\n              .body.document\n        )\n      )\n    )\n  }\n}\n\nfunction _upload(\n  client: SanityClient | ObservableSanityClient,\n  httpRequest: HttpRequest,\n  assetType: 'image' | 'file',\n  body: File | Blob | Buffer | NodeJS.ReadableStream,\n  opts: UploadClientConfig = {}\n): Observable<HttpRequestEvent<{document: SanityAssetDocument | SanityImageAssetDocument}>> {\n  validators.validateAssetType(assetType)\n\n  // If an empty array is given, explicitly set `none` to override API defaults\n  let meta = opts.extract || undefined\n  if (meta && !meta.length) {\n    meta = ['none']\n  }\n\n  const dataset = validators.hasDataset(client.config())\n  const assetEndpoint = assetType === 'image' ? 'images' : 'files'\n  const options = optionsFromFile(opts, body)\n  const {tag, label, title, description, creditLine, filename, source} = options\n  const query: Any = {\n    label,\n    title,\n    description,\n    filename,\n    meta,\n    creditLine,\n  }\n  if (source) {\n    query.sourceId = source.id\n    query.sourceName = source.name\n    query.sourceUrl = source.url\n  }\n  return _requestObservable(client, httpRequest, {\n    tag,\n    method: 'POST',\n    timeout: options.timeout || 0,\n    uri: `/assets/${assetEndpoint}/${dataset}`,\n    headers: options.contentType ? {'Content-Type': options.contentType} : {},\n    query,\n    body,\n  })\n}\n\nfunction optionsFromFile(opts: Record<string, Any>, file: Any) {\n  if (typeof window === 'undefined' || !(file instanceof window.File)) {\n    return opts\n  }\n\n  return Object.assign(\n    {\n      filename: opts.preserveFilename === false ? undefined : file.name,\n      contentType: file.type,\n    },\n    opts\n  )\n}\n","const BASE_URL = 'https://www.sanity.io/help/'\n\nexport function generateHelpUrl(slug: string) {\n  return BASE_URL + slug\n}\n","import type {Any} from '../types'\n\nexport function once(fn: Any) {\n  let didCall = false\n  let returnValue: Any\n  return (...args: Any[]) => {\n    if (didCall) {\n      return returnValue\n    }\n    returnValue = fn(...args)\n    didCall = true\n    return returnValue\n  }\n}\n","import {generateHelpUrl} from './generateHelpUrl'\nimport {Any} from './types'\nimport {once} from './util/once'\n\nconst createWarningPrinter = (message: string[]) =>\n  // eslint-disable-next-line no-console\n  once((...args: Any[]) => console.warn(message.join(' '), ...args))\n\nexport const printCdnWarning = createWarningPrinter([\n  'You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and',\n  `cheaper. Think about it! For more info, see ${generateHelpUrl('js-client-cdn-configuration')} `,\n  'To hide this warning, please set the `useCdn` option to either `true` or `false` when creating',\n  'the client.',\n])\n\nexport const printBrowserTokenWarning = createWarningPrinter([\n  'You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.',\n  `See ${generateHelpUrl(\n    'js-client-browser-token'\n  )} for more information and how to hide this warning.`,\n])\n\nexport const printNoApiVersionSpecifiedWarning = createWarningPrinter([\n  'Using the Sanity client without specifying an API version is deprecated.',\n  `See ${generateHelpUrl('js-client-api-version')}`,\n])\n\nexport const printNoDefaultExport = createWarningPrinter([\n  'The default export of @sanity/client has been deprecated. Use the named export `createClient` instead',\n])\n","import {generateHelpUrl} from './generateHelpUrl'\nimport type {ClientConfig, InitializedClientConfig} from './types'\nimport * as validate from './validators'\nimport * as warnings from './warnings'\n\nconst defaultCdnHost = 'apicdn.sanity.io'\nexport const defaultConfig = {\n  apiHost: 'https://api.sanity.io',\n  apiVersion: '1',\n  useProjectHostname: true,\n} satisfies ClientConfig\n\nconst LOCALHOSTS = ['localhost', '127.0.0.1', '0.0.0.0']\nconst isLocal = (host: string) => LOCALHOSTS.indexOf(host) !== -1\n\nexport const validateApiVersion = function validateApiVersion(apiVersion: string) {\n  if (apiVersion === '1' || apiVersion === 'X') {\n    return\n  }\n\n  const apiDate = new Date(apiVersion)\n  const apiVersionValid =\n    /^\\d{4}-\\d{2}-\\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0\n\n  if (!apiVersionValid) {\n    throw new Error('Invalid API version string, expected `1` or date in format `YYYY-MM-DD`')\n  }\n}\n\nexport const initConfig = (\n  config: Partial<ClientConfig>,\n  prevConfig: Partial<ClientConfig>\n): InitializedClientConfig => {\n  const specifiedConfig = Object.assign({}, prevConfig, config)\n  if (!specifiedConfig.apiVersion) {\n    warnings.printNoApiVersionSpecifiedWarning()\n  }\n\n  const newConfig = Object.assign({} as InitializedClientConfig, defaultConfig, specifiedConfig)\n  const projectBased = newConfig.useProjectHostname\n\n  if (typeof Promise === 'undefined') {\n    const helpUrl = generateHelpUrl('js-client-promise-polyfill')\n    throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`)\n  }\n\n  if (projectBased && !newConfig.projectId) {\n    throw new Error('Configuration must contain `projectId`')\n  }\n\n  const isBrowser = typeof window !== 'undefined' && window.location && window.location.hostname\n  const isLocalhost = isBrowser && isLocal(window.location.hostname)\n\n  if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {\n    warnings.printBrowserTokenWarning()\n  } else if (typeof newConfig.useCdn === 'undefined') {\n    warnings.printCdnWarning()\n  }\n\n  if (projectBased) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the nullability here is wrong, as line 48 throws an error if it's undefined\n    validate.projectId(newConfig.projectId!)\n  }\n\n  if (newConfig.dataset) {\n    validate.dataset(newConfig.dataset)\n  }\n\n  if ('requestTagPrefix' in newConfig) {\n    // Allow setting and unsetting request tag prefix\n    newConfig.requestTagPrefix = newConfig.requestTagPrefix\n      ? validate.requestTag(newConfig.requestTagPrefix).replace(/\\.+$/, '')\n      : undefined\n  }\n\n  newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, '')\n  newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost\n  newConfig.useCdn = Boolean(newConfig.useCdn) && !newConfig.withCredentials\n\n  validateApiVersion(newConfig.apiVersion)\n\n  const hostParts = newConfig.apiHost.split('://', 2)\n  const protocol = hostParts[0]\n  const host = hostParts[1]\n  const cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host\n\n  if (newConfig.useProjectHostname) {\n    newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`\n    newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`\n  } else {\n    newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`\n    newConfig.cdnUrl = newConfig.url\n  }\n\n  return newConfig\n}\n","import type {Any} from '../types'\n\nexport default (obj: Any, defaults: Any) =>\n  Object.keys(defaults)\n    .concat(Object.keys(obj))\n    .reduce((target, prop) => {\n      target[prop] = typeof obj[prop] === 'undefined' ? defaults[prop] : obj[prop]\n\n      return target\n    }, {} as Any)\n","import {Any} from '../types'\n\nexport const pick = (obj: Any, props: Any) =>\n  props.reduce((selection: Any, prop: Any) => {\n    if (typeof obj[prop] === 'undefined') {\n      return selection\n    }\n\n    selection[prop] = obj[prop]\n    return selection\n  }, {})\n","import polyfilledEventSource from '@sanity/eventsource'\nimport {Observable} from 'rxjs'\n\nimport type {ObservableSanityClient, SanityClient} from '../SanityClient'\nimport type {Any, ListenEvent, ListenOptions, MutationEvent, QueryParams} from '../types'\nimport defaults from '../util/defaults'\nimport {pick} from '../util/pick'\nimport {_getDataUrl} from './dataMethods'\nimport {encodeQueryString} from './encodeQueryString'\n\n// Limit is 16K for a _request_, eg including headers. Have to account for an\n// unknown range of headers, but an average EventSource request from Chrome seems\n// to have around 700 bytes of cruft, so let us account for 1.2K to be \"safe\"\nconst MAX_URL_LENGTH = 16000 - 1200\nconst EventSource = polyfilledEventSource\n\nconst possibleOptions = [\n  'includePreviousRevision',\n  'includeResult',\n  'visibility',\n  'effectFormat',\n  'tag',\n]\n\nconst defaultOptions = {\n  includeResult: true,\n}\n\n/**\n * Set up a listener that will be notified when mutations occur on documents matching the provided query/filter.\n *\n * @param query - GROQ-filter to listen to changes for\n * @param params - Optional query parameters\n * @param options - Listener options\n * @internal\n */\nexport function _listen<R extends Record<string, Any> = Record<string, Any>>(\n  this: SanityClient | ObservableSanityClient,\n  query: string,\n  params?: QueryParams\n): Observable<MutationEvent<R>>\n/**\n * Set up a listener that will be notified when mutations occur on documents matching the provided query/filter.\n *\n * @param query - GROQ-filter to listen to changes for\n * @param params - Optional query parameters\n * @param options - Listener options\n * @internal\n */\nexport function _listen<R extends Record<string, Any> = Record<string, Any>>(\n  this: SanityClient | ObservableSanityClient,\n  query: string,\n  params?: QueryParams,\n  options?: ListenOptions\n): Observable<ListenEvent<R>>\n/** @internal */\nexport function _listen<R extends Record<string, Any> = Record<string, Any>>(\n  this: SanityClient | ObservableSanityClient,\n  query: string,\n  params?: QueryParams,\n  opts: ListenOptions = {}\n): Observable<MutationEvent<R> | ListenEvent<R>> {\n  const {url, token, withCredentials, requestTagPrefix} = this.config()\n  const tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join('.') : opts.tag\n  const options = {...defaults(opts, defaultOptions), tag}\n  const listenOpts = pick(options, possibleOptions)\n  const qs = encodeQueryString({query, params, options: {tag, ...listenOpts}})\n\n  const uri = `${url}${_getDataUrl(this, 'listen', qs)}`\n  if (uri.length > MAX_URL_LENGTH) {\n    return new Observable((observer) => observer.error(new Error('Query too large for listener')))\n  }\n\n  const listenFor = options.events ? options.events : ['mutation']\n  const shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1\n\n  const esOptions: EventSourceInit & {headers?: Record<string, string>} = {}\n  if (token || withCredentials) {\n    esOptions.withCredentials = true\n  }\n\n  if (token) {\n    esOptions.headers = {\n      Authorization: `Bearer ${token}`,\n    }\n  }\n\n  return new Observable((observer) => {\n    let es = getEventSource()\n    let reconnectTimer: NodeJS.Timeout\n    let stopped = false\n\n    function onError() {\n      if (stopped) {\n        return\n      }\n\n      emitReconnect()\n\n      // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt\n      if (stopped) {\n        return\n      }\n\n      // Unless we've explicitly stopped the ES (in which case `stopped` should be true),\n      // we should never be in a disconnected state. By default, EventSource will reconnect\n      // automatically, in which case it sets readyState to `CONNECTING`, but in some cases\n      // (like when a laptop lid is closed), it closes the connection. In these cases we need\n      // to explicitly reconnect.\n      if (es.readyState === EventSource.CLOSED) {\n        unsubscribe()\n        clearTimeout(reconnectTimer)\n        reconnectTimer = setTimeout(open, 100)\n      }\n    }\n\n    function onChannelError(err: Any) {\n      observer.error(cooerceError(err))\n    }\n\n    function onMessage(evt: Any) {\n      const event = parseEvent(evt)\n      return event instanceof Error ? observer.error(event) : observer.next(event)\n    }\n\n    function onDisconnect() {\n      stopped = true\n      unsubscribe()\n      observer.complete()\n    }\n\n    function unsubscribe() {\n      es.removeEventListener('error', onError, false)\n      es.removeEventListener('channelError', onChannelError, false)\n      es.removeEventListener('disconnect', onDisconnect, false)\n      listenFor.forEach((type: string) => es.removeEventListener(type, onMessage, false))\n      es.close()\n    }\n\n    function emitReconnect() {\n      if (shouldEmitReconnect) {\n        observer.next({type: 'reconnect'})\n      }\n    }\n\n    function getEventSource() {\n      const evs = new EventSource(uri, esOptions)\n      evs.addEventListener('error', onError, false)\n      evs.addEventListener('channelError', onChannelError, false)\n      evs.addEventListener('disconnect', onDisconnect, false)\n      listenFor.forEach((type: string) => evs.addEventListener(type, onMessage, false))\n      return evs\n    }\n\n    function open() {\n      es = getEventSource()\n    }\n\n    function stop() {\n      stopped = true\n      unsubscribe()\n    }\n\n    return stop\n  })\n}\n\nfunction parseEvent(event: Any) {\n  try {\n    const data = (event.data && JSON.parse(event.data)) || {}\n    return Object.assign({type: event.type}, data)\n  } catch (err) {\n    return err\n  }\n}\n\nfunction cooerceError(err: Any) {\n  if (err instanceof Error) {\n    return err\n  }\n\n  const evt = parseEvent(err)\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt))\n}\n\nfunction extractErrorMessage(err: Any) {\n  if (!err.error) {\n    return err.message || 'Unknown listener error'\n  }\n\n  if (err.error.description) {\n    return err.error.description\n  }\n\n  return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2)\n}\n","import {lastValueFrom, type Observable} from 'rxjs'\n\nimport {_request} from '../data/dataMethods'\nimport type {ObservableSanityClient, SanityClient} from '../SanityClient'\nimport type {DatasetAclMode, DatasetResponse, DatasetsResponse, HttpRequest} from '../types'\nimport * as validate from '../validators'\n\n/** @internal */\nexport class ObservableDatasetsClient {\n  #client: ObservableSanityClient\n  #httpRequest: HttpRequest\n  constructor(client: ObservableSanityClient, httpRequest: HttpRequest) {\n    this.#client = client\n    this.#httpRequest = httpRequest\n  }\n\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name: string, options?: {aclMode?: DatasetAclMode}): Observable<DatasetResponse> {\n    return _modify<DatasetResponse>(this.#client, this.#httpRequest, 'PUT', name, options)\n  }\n\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name: string, options?: {aclMode?: DatasetAclMode}): Observable<DatasetResponse> {\n    return _modify<DatasetResponse>(this.#client, this.#httpRequest, 'PATCH', name, options)\n  }\n\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name: string): Observable<{deleted: true}> {\n    return _modify<{deleted: true}>(this.#client, this.#httpRequest, 'DELETE', name)\n  }\n\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list(): Observable<DatasetsResponse> {\n    return _request<DatasetsResponse>(this.#client, this.#httpRequest, {uri: '/datasets'})\n  }\n}\n\n/** @internal */\nexport class DatasetsClient {\n  #client: SanityClient\n  #httpRequest: HttpRequest\n  constructor(client: SanityClient, httpRequest: HttpRequest) {\n    this.#client = client\n    this.#httpRequest = httpRequest\n  }\n\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name: string, options?: {aclMode?: DatasetAclMode}): Promise<DatasetResponse> {\n    return lastValueFrom(\n      _modify<DatasetResponse>(this.#client, this.#httpRequest, 'PUT', name, options)\n    )\n  }\n\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name: string, options?: {aclMode?: DatasetAclMode}): Promise<DatasetResponse> {\n    return lastValueFrom(\n      _modify<DatasetResponse>(this.#client, this.#httpRequest, 'PATCH', name, options)\n    )\n  }\n\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name: string): Promise<{deleted: true}> {\n    return lastValueFrom(_modify<{deleted: true}>(this.#client, this.#httpRequest, 'DELETE', name))\n  }\n\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list(): Promise<DatasetsResponse> {\n    return lastValueFrom(\n      _request<DatasetsResponse>(this.#client, this.#httpRequest, {uri: '/datasets'})\n    )\n  }\n}\n\nfunction _modify<R = unknown>(\n  client: SanityClient | ObservableSanityClient,\n  httpRequest: HttpRequest,\n  method: 'DELETE' | 'PATCH' | 'PUT',\n  name: string,\n  options?: {aclMode?: DatasetAclMode}\n) {\n  validate.dataset(name)\n  return _request<R>(client, httpRequest, {method, uri: `/datasets/${name}`, body: options})\n}\n","import {lastValueFrom, type Observable} from 'rxjs'\n\nimport {_request} from '../data/dataMethods'\nimport type {ObservableSanityClient, SanityClient} from '../SanityClient'\nimport type {HttpRequest, SanityProject} from '../types'\n\n/** @internal */\nexport class ObservableProjectsClient {\n  #client: ObservableSanityClient\n  #httpRequest: HttpRequest\n  constructor(client: ObservableSanityClient, httpRequest: HttpRequest) {\n    this.#client = client\n    this.#httpRequest = httpRequest\n  }\n\n  /**\n   * Fetch a list of projects the authenticated user has access to\n   */\n  list(): Observable<SanityProject[]> {\n    return _request<SanityProject[]>(this.#client, this.#httpRequest, {uri: '/projects'})\n  }\n\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId: string): Observable<SanityProject> {\n    return _request<SanityProject>(this.#client, this.#httpRequest, {uri: `/projects/${projectId}`})\n  }\n}\n\n/** @internal */\nexport class ProjectsClient {\n  #client: SanityClient\n  #httpRequest: HttpRequest\n  constructor(client: SanityClient, httpRequest: HttpRequest) {\n    this.#client = client\n    this.#httpRequest = httpRequest\n  }\n\n  /**\n   * Fetch a list of projects the authenticated user has access to\n   */\n  list(): Promise<SanityProject[]> {\n    return lastValueFrom(\n      _request<SanityProject[]>(this.#client, this.#httpRequest, {uri: '/projects'})\n    )\n  }\n\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId: string): Promise<SanityProject> {\n    return lastValueFrom(\n      _request<SanityProject>(this.#client, this.#httpRequest, {uri: `/projects/${projectId}`})\n    )\n  }\n}\n","import {lastValueFrom, type Observable} from 'rxjs'\n\nimport {_request} from '../data/dataMethods'\nimport type {ObservableSanityClient, SanityClient} from '../SanityClient'\nimport type {CurrentSanityUser, HttpRequest, SanityUser} from '../types'\n\n/** @public */\nexport class ObservableUsersClient {\n  #client: ObservableSanityClient\n  #httpRequest: HttpRequest\n  constructor(client: ObservableSanityClient, httpRequest: HttpRequest) {\n    this.#client = client\n    this.#httpRequest = httpRequest\n  }\n\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById<T extends 'me' | string>(\n    id: T\n  ): Observable<T extends 'me' ? CurrentSanityUser : SanityUser> {\n    return _request<T extends 'me' ? CurrentSanityUser : SanityUser>(\n      this.#client,\n      this.#httpRequest,\n      {uri: `/users/${id}`}\n    )\n  }\n}\n\n/** @public */\nexport class UsersClient {\n  #client: SanityClient\n  #httpRequest: HttpRequest\n  constructor(client: SanityClient, httpRequest: HttpRequest) {\n    this.#client = client\n    this.#httpRequest = httpRequest\n  }\n\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById<T extends 'me' | string>(\n    id: T\n  ): Promise<T extends 'me' ? CurrentSanityUser : SanityUser> {\n    return lastValueFrom(\n      _request<T extends 'me' ? CurrentSanityUser : SanityUser>(this.#client, this.#httpRequest, {\n        uri: `/users/${id}`,\n      })\n    )\n  }\n}\n","import {lastValueFrom, Observable} from 'rxjs'\n\nimport {AssetsClient, ObservableAssetsClient} from './assets/AssetsClient'\nimport {defaultConfig, initConfig} from './config'\nimport * as dataMethods from './data/dataMethods'\nimport {_listen} from './data/listen'\nimport {ObservablePatch, Patch} from './data/patch'\nimport {ObservableTransaction, Transaction} from './data/transaction'\nimport {DatasetsClient, ObservableDatasetsClient} from './datasets/DatasetsClient'\nimport {ObservableProjectsClient, ProjectsClient} from './projects/ProjectsClient'\nimport type {\n  AllDocumentIdsMutationOptions,\n  AllDocumentsMutationOptions,\n  Any,\n  BaseMutationOptions,\n  ClientConfig,\n  FilteredResponseQueryOptions,\n  FirstDocumentIdMutationOptions,\n  FirstDocumentMutationOptions,\n  HttpRequest,\n  IdentifiedSanityDocumentStub,\n  InitializedClientConfig,\n  MultipleMutationResult,\n  Mutation,\n  MutationSelection,\n  PatchOperations,\n  PatchSelection,\n  QueryParams,\n  RawQueryResponse,\n  RawRequestOptions,\n  SanityDocument,\n  SanityDocumentStub,\n  SingleMutationResult,\n  UnfilteredResponseQueryOptions,\n} from './types'\nimport {ObservableUsersClient, UsersClient} from './users/UsersClient'\n\nexport type {\n  _listen,\n  AssetsClient,\n  DatasetsClient,\n  ObservableAssetsClient,\n  ObservableDatasetsClient,\n  ObservableProjectsClient,\n  ObservableUsersClient,\n  ProjectsClient,\n  UsersClient,\n}\n\n/** @public */\nexport class ObservableSanityClient {\n  assets: ObservableAssetsClient\n  datasets: ObservableDatasetsClient\n  projects: ObservableProjectsClient\n  users: ObservableUsersClient\n\n  /**\n   * Private properties\n   */\n  #clientConfig: InitializedClientConfig\n  #httpRequest: HttpRequest\n\n  /**\n   * Instance properties\n   */\n  listen = _listen\n\n  constructor(httpRequest: HttpRequest, config: ClientConfig = defaultConfig) {\n    this.config(config)\n\n    this.#httpRequest = httpRequest\n\n    this.assets = new ObservableAssetsClient(this, this.#httpRequest)\n    this.datasets = new ObservableDatasetsClient(this, this.#httpRequest)\n    this.projects = new ObservableProjectsClient(this, this.#httpRequest)\n    this.users = new ObservableUsersClient(this, this.#httpRequest)\n  }\n\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone(): ObservableSanityClient {\n    return new ObservableSanityClient(this.#httpRequest, this.config())\n  }\n\n  /**\n   * Returns the current client configuration\n   */\n  config(): InitializedClientConfig\n  /**\n   * Reconfigure the client. Note that this _mutates_ the current client.\n   */\n  config(newConfig?: Partial<ClientConfig>): this\n  config(newConfig?: Partial<ClientConfig>): ClientConfig | this {\n    if (newConfig === undefined) {\n      return {...this.#clientConfig}\n    }\n\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === false) {\n      throw new Error(\n        'Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client'\n      )\n    }\n\n    this.#clientConfig = initConfig(newConfig, this.#clientConfig || {})\n    return this\n  }\n\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig?: Partial<ClientConfig>): ObservableSanityClient {\n    return new ObservableSanityClient(this.#httpRequest, {...this.config(), ...newConfig})\n  }\n\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   */\n  fetch<R = Any>(query: string): Observable<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Query parameters\n   */\n  fetch<R = Any, Q = QueryParams>(query: string, params: Q): Observable<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Query parameters\n   * @param options - Request options\n   */\n  fetch<R = Any, Q = QueryParams>(\n    query: string,\n    params: Q | undefined,\n    options: FilteredResponseQueryOptions\n  ): Observable<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Query parameters\n   * @param options - Request options\n   */\n  fetch<R = Any, Q = QueryParams>(\n    query: string,\n    params: Q | undefined,\n    options: UnfilteredResponseQueryOptions\n  ): Observable<RawQueryResponse<R>>\n  fetch<R, Q extends QueryParams>(\n    query: string,\n    params?: Q,\n    options: FilteredResponseQueryOptions | UnfilteredResponseQueryOptions = {}\n  ): Observable<RawQueryResponse<R> | R> {\n    return dataMethods._fetch<R, Q>(this, this.#httpRequest, query, params, options)\n  }\n\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument<R extends Record<string, Any> = Record<string, Any>>(\n    id: string,\n    options?: {tag?: string}\n  ): Observable<SanityDocument<R> | undefined> {\n    return dataMethods._getDocument<R>(this, this.#httpRequest, id, options)\n  }\n\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments<R extends Record<string, Any> = Record<string, Any>>(\n    ids: string[],\n    options?: {tag?: string}\n  ): Observable<(SanityDocument<R> | null)[]> {\n    return dataMethods._getDocuments<R>(this, this.#httpRequest, ids, options)\n  }\n\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns an observable that resolves to the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options: FirstDocumentMutationOptions\n  ): Observable<SanityDocument<R>>\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns an observable that resolves to an array containing the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options: AllDocumentsMutationOptions\n  ): Observable<SanityDocument<R>[]>\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns an observable that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options: FirstDocumentIdMutationOptions\n  ): Observable<SingleMutationResult>\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns an observable that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options: AllDocumentIdsMutationOptions\n  ): Observable<MultipleMutationResult>\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns an observable that resolves to the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options?: BaseMutationOptions\n  ): Observable<SanityDocument<R>>\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options?:\n      | AllDocumentIdsMutationOptions\n      | AllDocumentsMutationOptions\n      | BaseMutationOptions\n      | FirstDocumentIdMutationOptions\n      | FirstDocumentMutationOptions\n  ): Observable<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return dataMethods._create<R>(this, this.#httpRequest, document, 'create', options)\n  }\n\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns an observable that resolves to the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: FirstDocumentMutationOptions\n  ): Observable<SanityDocument<R>>\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns an observable that resolves to an array containing the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: AllDocumentsMutationOptions\n  ): Observable<SanityDocument<R>[]>\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns an observable that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: FirstDocumentIdMutationOptions\n  ): Observable<SingleMutationResult>\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns an observable that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: AllDocumentIdsMutationOptions\n  ): Observable<MultipleMutationResult>\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns an observable that resolves to the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options?: BaseMutationOptions\n  ): Observable<SanityDocument<R>>\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options?:\n      | AllDocumentIdsMutationOptions\n      | AllDocumentsMutationOptions\n      | BaseMutationOptions\n      | FirstDocumentIdMutationOptions\n      | FirstDocumentMutationOptions\n  ): Observable<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return dataMethods._createIfNotExists<R>(this, this.#httpRequest, document, options)\n  }\n\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns an observable that resolves to the created document.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: FirstDocumentMutationOptions\n  ): Observable<SanityDocument<R>>\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns an observable that resolves to an array containing the created document.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: AllDocumentsMutationOptions\n  ): Observable<SanityDocument<R>[]>\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns an observable that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: FirstDocumentIdMutationOptions\n  ): Observable<SingleMutationResult>\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns an observable that resolves to a mutation result object containing the created document ID.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: AllDocumentIdsMutationOptions\n  ): Observable<MultipleMutationResult>\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns an observable that resolves to the created document.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options?: BaseMutationOptions\n  ): Observable<SanityDocument<R>>\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options?:\n      | AllDocumentIdsMutationOptions\n      | AllDocumentsMutationOptions\n      | BaseMutationOptions\n      | FirstDocumentIdMutationOptions\n      | FirstDocumentMutationOptions\n  ): Observable<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return dataMethods._createOrReplace<R>(this, this.#httpRequest, document, options)\n  }\n\n  /**\n   * Deletes a document with the given document ID.\n   * Returns an observable that resolves to the deleted document.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    id: string,\n    options: FirstDocumentMutationOptions\n  ): Observable<SanityDocument<R>>\n  /**\n   * Deletes a document with the given document ID.\n   * Returns an observable that resolves to an array containing the deleted document.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    id: string,\n    options: AllDocumentsMutationOptions\n  ): Observable<SanityDocument<R>[]>\n  /**\n   * Deletes a document with the given document ID.\n   * Returns an observable that resolves to a mutation result object containing the deleted document ID.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete(id: string, options: FirstDocumentIdMutationOptions): Observable<SingleMutationResult>\n  /**\n   * Deletes a document with the given document ID.\n   * Returns an observable that resolves to a mutation result object containing the deleted document ID.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete(id: string, options: AllDocumentIdsMutationOptions): Observable<MultipleMutationResult>\n  /**\n   * Deletes a document with the given document ID.\n   * Returns an observable that resolves to the deleted document.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    id: string,\n    options?: BaseMutationOptions\n  ): Observable<SanityDocument<R>>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns an observable that resolves to first deleted document.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    selection: MutationSelection,\n    options: FirstDocumentMutationOptions\n  ): Observable<SanityDocument<R>>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns an observable that resolves to an array containing the deleted documents.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    selection: MutationSelection,\n    options: AllDocumentsMutationOptions\n  ): Observable<SanityDocument<R>[]>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns an observable that resolves to a mutation result object containing the ID of the first deleted document.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete(\n    selection: MutationSelection,\n    options: FirstDocumentIdMutationOptions\n  ): Observable<SingleMutationResult>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns an observable that resolves to a mutation result object containing the document IDs that were deleted.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete(\n    selection: MutationSelection,\n    options: AllDocumentIdsMutationOptions\n  ): Observable<MultipleMutationResult>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns an observable that resolves to first deleted document.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    selection: MutationSelection,\n    options?: BaseMutationOptions\n  ): Observable<SanityDocument<R>>\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    selection: string | MutationSelection,\n    options?:\n      | AllDocumentIdsMutationOptions\n      | AllDocumentsMutationOptions\n      | BaseMutationOptions\n      | FirstDocumentIdMutationOptions\n      | FirstDocumentMutationOptions\n  ): Observable<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return dataMethods._delete<R>(this, this.#httpRequest, selection, options)\n  }\n\n  /**\n   * Perform mutation operations against the configured dataset\n   * Returns an observable that resolves to the first mutated document.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | ObservablePatch | ObservableTransaction,\n    options: FirstDocumentMutationOptions\n  ): Observable<SanityDocument<R>>\n  /**\n   * Perform mutation operations against the configured dataset.\n   * Returns an observable that resolves to an array of the mutated documents.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | ObservablePatch | ObservableTransaction,\n    options: AllDocumentsMutationOptions\n  ): Observable<SanityDocument<R>[]>\n  /**\n   * Perform mutation operations against the configured dataset\n   * Returns an observable that resolves to a mutation result object containing the document ID of the first mutated document.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | ObservablePatch | ObservableTransaction,\n    options: FirstDocumentIdMutationOptions\n  ): Observable<SingleMutationResult>\n  /**\n   * Perform mutation operations against the configured dataset\n   * Returns an observable that resolves to a mutation result object containing the mutated document IDs.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | ObservablePatch | ObservableTransaction,\n    options: AllDocumentIdsMutationOptions\n  ): Observable<MultipleMutationResult>\n  /**\n   * Perform mutation operations against the configured dataset\n   * Returns an observable that resolves to the first mutated document.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | ObservablePatch | ObservableTransaction,\n    options?: BaseMutationOptions\n  ): Observable<SanityDocument<R>>\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | ObservablePatch | ObservableTransaction,\n    options?:\n      | FirstDocumentMutationOptions\n      | AllDocumentsMutationOptions\n      | FirstDocumentIdMutationOptions\n      | AllDocumentIdsMutationOptions\n      | BaseMutationOptions\n  ): Observable<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return dataMethods._mutate<R>(this, this.#httpRequest, operations, options)\n  }\n\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param documentId - Document ID(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   */\n  patch(documentId: PatchSelection, operations?: PatchOperations): ObservablePatch {\n    return new ObservablePatch(documentId, operations, this)\n  }\n\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction<R extends Record<string, Any> = Record<string, Any>>(\n    operations?: Mutation<R>[]\n  ): ObservableTransaction {\n    return new ObservableTransaction(operations, this)\n  }\n\n  /**\n   * DEPRECATED: Perform an HTTP request against the Sanity API\n   *\n   * @deprecated Use your own request library!\n   * @param options - Request options\n   */\n  request<R = Any>(options: RawRequestOptions): Observable<R> {\n    return dataMethods._request(this, this.#httpRequest, options)\n  }\n\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri: string, canUseCdn?: boolean): string {\n    return dataMethods._getUrl(this, uri, canUseCdn)\n  }\n\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation: string, path?: string): string {\n    return dataMethods._getDataUrl(this, operation, path)\n  }\n}\n\n/** @public */\nexport class SanityClient {\n  assets: AssetsClient\n  datasets: DatasetsClient\n  projects: ProjectsClient\n  users: UsersClient\n\n  /**\n   * Observable version of the Sanity client, with the same configuration as the promise-based one\n   */\n  observable: ObservableSanityClient\n\n  /**\n   * Private properties\n   */\n  #clientConfig: InitializedClientConfig\n  #httpRequest: HttpRequest\n\n  /**\n   * Instance properties\n   */\n  listen = _listen\n\n  constructor(httpRequest: HttpRequest, config: ClientConfig = defaultConfig) {\n    this.config(config)\n\n    this.#httpRequest = httpRequest\n\n    this.assets = new AssetsClient(this, this.#httpRequest)\n    this.datasets = new DatasetsClient(this, this.#httpRequest)\n    this.projects = new ProjectsClient(this, this.#httpRequest)\n    this.users = new UsersClient(this, this.#httpRequest)\n\n    this.observable = new ObservableSanityClient(httpRequest, config)\n  }\n\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone(): SanityClient {\n    return new SanityClient(this.#httpRequest, this.config())\n  }\n\n  /**\n   * Returns the current client configuration\n   */\n  config(): InitializedClientConfig\n  /**\n   * Reconfigure the client. Note that this _mutates_ the current client.\n   */\n  config(newConfig?: Partial<ClientConfig>): this\n  config(newConfig?: Partial<ClientConfig>): ClientConfig | this {\n    if (newConfig === undefined) {\n      return {...this.#clientConfig}\n    }\n\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === false) {\n      throw new Error(\n        'Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client'\n      )\n    }\n\n    if (this.observable) {\n      this.observable.config(newConfig)\n    }\n\n    this.#clientConfig = initConfig(newConfig, this.#clientConfig || {})\n    return this\n  }\n\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig?: Partial<ClientConfig>): SanityClient {\n    return new SanityClient(this.#httpRequest, {...this.config(), ...newConfig})\n  }\n\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   */\n  fetch<R = Any>(query: string): Promise<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Optional query parameters\n   */\n  fetch<R = Any, Q = QueryParams>(query: string, params: Q): Promise<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Optional query parameters\n   * @param options - Request options\n   */\n  fetch<R = Any, Q = QueryParams>(\n    query: string,\n    params: Q | undefined,\n    options: FilteredResponseQueryOptions\n  ): Promise<R>\n  /**\n   * Perform a GROQ-query against the configured dataset.\n   *\n   * @param query - GROQ-query to perform\n   * @param params - Optional query parameters\n   * @param options - Request options\n   */\n  fetch<R = Any, Q = QueryParams>(\n    query: string,\n    params: Q | undefined,\n    options: UnfilteredResponseQueryOptions\n  ): Promise<RawQueryResponse<R>>\n  fetch<R, Q extends QueryParams>(\n    query: string,\n    params?: Q,\n    options: FilteredResponseQueryOptions | UnfilteredResponseQueryOptions = {}\n  ): Promise<RawQueryResponse<R> | R> {\n    return lastValueFrom(dataMethods._fetch<R, Q>(this, this.#httpRequest, query, params, options))\n  }\n\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument<R extends Record<string, Any> = Record<string, Any>>(\n    id: string,\n    options?: {tag?: string}\n  ): Promise<SanityDocument<R> | undefined> {\n    return lastValueFrom(dataMethods._getDocument<R>(this, this.#httpRequest, id, options))\n  }\n\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments<R extends Record<string, Any> = Record<string, Any>>(\n    ids: string[],\n    options?: {tag?: string}\n  ): Promise<(SanityDocument<R> | null)[]> {\n    return lastValueFrom(dataMethods._getDocuments<R>(this, this.#httpRequest, ids, options))\n  }\n\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns a promise that resolves to the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options: FirstDocumentMutationOptions\n  ): Promise<SanityDocument<R>>\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns a promise that resolves to an array containing the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options: AllDocumentsMutationOptions\n  ): Promise<SanityDocument<R>[]>\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns a promise that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options: FirstDocumentIdMutationOptions\n  ): Promise<SingleMutationResult>\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns a promise that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options: AllDocumentIdsMutationOptions\n  ): Promise<MultipleMutationResult>\n  /**\n   * Create a document. Requires a `_type` property. If no `_id` is provided, it will be generated by the database.\n   * Returns a promise that resolves to the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options?: BaseMutationOptions\n  ): Promise<SanityDocument<R>>\n  create<R extends Record<string, Any> = Record<string, Any>>(\n    document: SanityDocumentStub<R>,\n    options?:\n      | AllDocumentIdsMutationOptions\n      | AllDocumentsMutationOptions\n      | BaseMutationOptions\n      | FirstDocumentIdMutationOptions\n      | FirstDocumentMutationOptions\n  ): Promise<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return lastValueFrom(\n      dataMethods._create<R>(this, this.#httpRequest, document, 'create', options)\n    )\n  }\n\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns a promise that resolves to the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: FirstDocumentMutationOptions\n  ): Promise<SanityDocument<R>>\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns a promise that resolves to an array containing the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: AllDocumentsMutationOptions\n  ): Promise<SanityDocument<R>[]>\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns a promise that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: FirstDocumentIdMutationOptions\n  ): Promise<SingleMutationResult>\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns a promise that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: AllDocumentIdsMutationOptions\n  ): Promise<MultipleMutationResult>\n  /**\n   * Create a document if no document with the same ID already exists.\n   * Returns a promise that resolves to the created document.\n   *\n   * @param document - Document to create\n   * @param options - Mutation options\n   */\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options?: BaseMutationOptions\n  ): Promise<SanityDocument<R>>\n  createIfNotExists<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options?:\n      | AllDocumentIdsMutationOptions\n      | AllDocumentsMutationOptions\n      | BaseMutationOptions\n      | FirstDocumentIdMutationOptions\n      | FirstDocumentMutationOptions\n  ): Promise<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return lastValueFrom(\n      dataMethods._createIfNotExists<R>(this, this.#httpRequest, document, options)\n    )\n  }\n\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns a promise that resolves to the created document.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: FirstDocumentMutationOptions\n  ): Promise<SanityDocument<R>>\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns a promise that resolves to an array containing the created document.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: AllDocumentsMutationOptions\n  ): Promise<SanityDocument<R>[]>\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns a promise that resolves to a mutation result object containing the ID of the created document.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: FirstDocumentIdMutationOptions\n  ): Promise<SingleMutationResult>\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns a promise that resolves to a mutation result object containing the created document ID.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options: AllDocumentIdsMutationOptions\n  ): Promise<MultipleMutationResult>\n  /**\n   * Create a document if it does not exist, or replace a document with the same document ID\n   * Returns a promise that resolves to the created document.\n   *\n   * @param document - Document to either create or replace\n   * @param options - Mutation options\n   */\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options?: BaseMutationOptions\n  ): Promise<SanityDocument<R>>\n  createOrReplace<R extends Record<string, Any> = Record<string, Any>>(\n    document: IdentifiedSanityDocumentStub<R>,\n    options?:\n      | AllDocumentIdsMutationOptions\n      | AllDocumentsMutationOptions\n      | BaseMutationOptions\n      | FirstDocumentIdMutationOptions\n      | FirstDocumentMutationOptions\n  ): Promise<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return lastValueFrom(\n      dataMethods._createOrReplace<R>(this, this.#httpRequest, document, options)\n    )\n  }\n\n  /**\n   * Deletes a document with the given document ID.\n   * Returns a promise that resolves to the deleted document.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    id: string,\n    options: FirstDocumentMutationOptions\n  ): Promise<SanityDocument<R>>\n  /**\n   * Deletes a document with the given document ID.\n   * Returns a promise that resolves to an array containing the deleted document.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    id: string,\n    options: AllDocumentsMutationOptions\n  ): Promise<SanityDocument<R>[]>\n  /**\n   * Deletes a document with the given document ID.\n   * Returns a promise that resolves to a mutation result object containing the deleted document ID.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete(id: string, options: FirstDocumentIdMutationOptions): Promise<SingleMutationResult>\n  /**\n   * Deletes a document with the given document ID.\n   * Returns a promise that resolves to a mutation result object containing the deleted document ID.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete(id: string, options: AllDocumentIdsMutationOptions): Promise<MultipleMutationResult>\n  /**\n   * Deletes a document with the given document ID.\n   * Returns a promise that resolves to the deleted document.\n   *\n   * @param id - Document ID to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    id: string,\n    options?: BaseMutationOptions\n  ): Promise<SanityDocument<R>>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns a promise that resolves to first deleted document.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    selection: MutationSelection,\n    options: FirstDocumentMutationOptions\n  ): Promise<SanityDocument<R>>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns a promise that resolves to an array containing the deleted documents.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    selection: MutationSelection,\n    options: AllDocumentsMutationOptions\n  ): Promise<SanityDocument<R>[]>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns a promise that resolves to a mutation result object containing the ID of the first deleted document.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete(\n    selection: MutationSelection,\n    options: FirstDocumentIdMutationOptions\n  ): Promise<SingleMutationResult>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns a promise that resolves to a mutation result object containing the document IDs that were deleted.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete(\n    selection: MutationSelection,\n    options: AllDocumentIdsMutationOptions\n  ): Promise<MultipleMutationResult>\n  /**\n   * Deletes one or more documents matching the given query or document ID.\n   * Returns a promise that resolves to first deleted document.\n   *\n   * @param selection - An object with either an `id` or `query` key defining what to delete\n   * @param options - Options for the mutation\n   */\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    selection: MutationSelection,\n    options?: BaseMutationOptions\n  ): Promise<SanityDocument<R>>\n  delete<R extends Record<string, Any> = Record<string, Any>>(\n    selection: string | MutationSelection,\n    options?:\n      | AllDocumentIdsMutationOptions\n      | AllDocumentsMutationOptions\n      | BaseMutationOptions\n      | FirstDocumentIdMutationOptions\n      | FirstDocumentMutationOptions\n  ): Promise<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return lastValueFrom(dataMethods._delete<R>(this, this.#httpRequest, selection, options))\n  }\n\n  /**\n   * Perform mutation operations against the configured dataset\n   * Returns a promise that resolves to the first mutated document.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | Patch | Transaction,\n    options: FirstDocumentMutationOptions\n  ): Promise<SanityDocument<R>>\n  /**\n   * Perform mutation operations against the configured dataset.\n   * Returns a promise that resolves to an array of the mutated documents.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | Patch | Transaction,\n    options: AllDocumentsMutationOptions\n  ): Promise<SanityDocument<R>[]>\n  /**\n   * Perform mutation operations against the configured dataset\n   * Returns a promise that resolves to a mutation result object containing the document ID of the first mutated document.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | Patch | Transaction,\n    options: FirstDocumentIdMutationOptions\n  ): Promise<SingleMutationResult>\n  /**\n   * Perform mutation operations against the configured dataset\n   * Returns a promise that resolves to a mutation result object containing the mutated document IDs.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any>>(\n    operations: Mutation<R>[] | Patch | Transaction,\n    options: AllDocumentIdsMutationOptions\n  ): Promise<MultipleMutationResult>\n  /**\n   * Perform mutation operations against the configured dataset\n   * Returns a promise that resolves to the first mutated document.\n   *\n   * @param operations - Mutation operations to execute\n   * @param options - Mutation options\n   */\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | Patch | Transaction,\n    options?: BaseMutationOptions\n  ): Promise<SanityDocument<R>>\n  mutate<R extends Record<string, Any> = Record<string, Any>>(\n    operations: Mutation<R>[] | Patch | Transaction,\n    options?:\n      | FirstDocumentMutationOptions\n      | AllDocumentsMutationOptions\n      | FirstDocumentIdMutationOptions\n      | AllDocumentIdsMutationOptions\n      | BaseMutationOptions\n  ): Promise<\n    SanityDocument<R> | SanityDocument<R>[] | SingleMutationResult | MultipleMutationResult\n  > {\n    return lastValueFrom(dataMethods._mutate<R>(this, this.#httpRequest, operations, options))\n  }\n\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param documentId - Document ID(s)to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   */\n  patch(documentId: PatchSelection, operations?: PatchOperations): Patch {\n    return new Patch(documentId, operations, this)\n  }\n\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction<R extends Record<string, Any> = Record<string, Any>>(\n    operations?: Mutation<R>[]\n  ): Transaction {\n    return new Transaction(operations, this)\n  }\n\n  /**\n   * DEPRECATED: Perform an HTTP request against the Sanity API\n   *\n   * @deprecated Use your own request library!\n   * @param options - Request options\n   */\n  request<R = Any>(options: RawRequestOptions): Promise<R> {\n    return lastValueFrom(dataMethods._request<R>(this, this.#httpRequest, options))\n  }\n\n  /**\n   * DEPRECATED: Perform an HTTP request a `/data` sub-endpoint\n   *\n   * @deprecated Use your own request library!\n   * @param endpoint - Endpoint to hit (mutate, query etc)\n   * @param body - Request body\n   * @param options - Request options\n   */\n  dataRequest(endpoint: string, body: unknown, options?: BaseMutationOptions): Promise<Any> {\n    return lastValueFrom(dataMethods._dataRequest(this, this.#httpRequest, endpoint, body, options))\n  }\n\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri: string, canUseCdn?: boolean): string {\n    return dataMethods._getUrl(this, uri, canUseCdn)\n  }\n\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation: string, path?: string): string {\n    return dataMethods._getDataUrl(this, operation, path)\n  }\n}\n","import envMiddleware from './http/browserMiddleware'\nimport {defineHttpRequest} from './http/request'\nimport {SanityClient} from './SanityClient'\nimport type {ClientConfig} from './types'\nimport {printNoDefaultExport} from './warnings'\n\nexport * from './data/patch'\nexport * from './data/transaction'\nexport {ClientError, ServerError} from './http/errors'\nexport * from './SanityClient'\nexport * from './types'\n\n// Set the http client to use for requests, and its environment specific middleware\nconst httpRequest = defineHttpRequest(envMiddleware)\n/** @public */\nexport const requester = httpRequest.defaultRequester\n\n/** @public */\nexport const createClient = (config: ClientConfig) => new SanityClient(httpRequest, config)\n\n/**\n * @public\n * @deprecated Use the named export `createClient` instead of the `default` export\n */\nexport default function deprecatedCreateClient(config: ClientConfig) {\n  printNoDefaultExport()\n  return new SanityClient(httpRequest, config)\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}